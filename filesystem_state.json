{"file_contents":{"src/main/java/com/github/koxsosen/commands/EmbedCommand.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.commands;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\nimport org.javacord.api.entity.message.embed.EmbedBuilder;\n\nimport java.awt.Color;\n\npublic class EmbedCommand implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(EmbedCommand.class);\n\n    @Command(aliases = {Constants.PREFIX + \"embed\"}, async = true, description = \"Create a custom embed message\", usage = \"/embed <title> | <description>\")\n    public void onCommand(TextChannel channel, Message message, String[] args) {\n\n        if (args.length == 0) {\n            channel.sendMessage(\"Usage: `/embed <title> | <description>`\\nExample: `/embed Welcome | This is an example embed`\");\n            return;\n        }\n\n        String fullMessage = String.join(\" \", args);\n        String[] parts = fullMessage.split(\"\\\\|\", 2);\n\n        String title = parts.length > 0 ? parts[0].trim() : \"Embed\";\n        String description = parts.length > 1 ? parts[1].trim() : \"\";\n\n        EmbedBuilder embed = new EmbedBuilder()\n                .setTitle(title)\n                .setDescription(description)\n                .setColor(Color.decode(\"#005A9C\"));\n\n        channel.sendMessage(embed);\n        logger.info(message.getAuthor() + \" used embed command\");\n    }\n}\n","size_bytes":2255},"src/main/java/com/github/koxsosen/commands/HelpCommand.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.commands;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\nimport org.javacord.api.entity.message.MessageBuilder;\n\npublic class HelpCommand implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(HelpCommand.class);\n\n    private static final String prefix = Constants.PREFIX();\n\n    @Command(aliases = {Constants.PREFIX + \"help\", Constants.PREFIX + \"halp\"}, async = true, description = \"Help command for ducky\")\n    public void onCommand(TextChannel channel, Message message) {\n\n        new MessageBuilder()\n                .append(\"<@&1350907647217635389>\")\n                .append(\"\\n**Los Angeles Roleplay Bot** - Commands:\")\n                .append(\"\\n \\n**General Commands:**\")\n                .append(\"\\n - Web Search: `\" + prefix + \"g` \")\n                .append(\"\\n - Random Cat Image: `\" + prefix + \"cat` \" )\n                .append(\"\\n - Random Duck Image: `\" + prefix + \"duck`\" )\n                .append(\"\\n - Random Dog Image: `\" + prefix + \"dog`\")\n                .append(\"\\n - Self Hosted Paste Server: `\" + prefix + \"paste` \" )\n                .append(\"\\n - Website: `\" + prefix + \"site` \" )\n                .append(\"\\n - Invite the bot: `\" + prefix + \"inv` \" )\n                .append(\"\\n - Create Embed: `\" + prefix + \"embed` \" )\n                .append(\"\\n - Help: `\" + prefix + \"help`  \" )\n                .append(\"\\n \\n**Moderation Commands** (Requires <@&1350907647217635389>):\")\n                .append(\"\\n - Mute User: `\" + prefix + \"mute @user <time>` \" )\n                .append(\"\\n - Kick User: `\" + prefix + \"kick @user <reason>` \" )\n                .append(\"\\n - Ban User: `\" + prefix + \"ban @user <reason>` \" )\n\n                .send(channel);\n\n        logger.info(message.getAuthor());\n    }\n}","size_bytes":2763},"src/main/java/com/github/koxsosen/commands/WebSearch.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.commands;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\nimport org.javacord.api.entity.message.MessageBuilder;\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.select.Elements;\n\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Objects;\n\npublic class WebSearch implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(WebSearch.class);\n\n    private final HashMap<Long, Long> cooldown = new HashMap <>();\n\n    int maxcharacters = 500;\n\n    String formatted = null;\n\n    String search = null;\n\n    @Command(aliases = {Constants.PREFIX + \"g\"}, async = true, description = \"Runs a web search on \" + Constants.SCRAPEURL)\n    public void onCommand(TextChannel channel, Message message) {\n\n        if (cooldown.getOrDefault(message.getAuthor().getId(), 0L) > System.currentTimeMillis() - 4000) {\n            channel.sendMessage(\"**Ducky** - Please wait `4` seconds before running this command again.\");\n            logger.info(\"Cooldown: \" + message.getAuthor() + \" in \" + channel.getId());\n            return;\n        }\n\n        cooldown.put(message.getAuthor().getId(), System.currentTimeMillis());\n\n        String content = message.getContent()\n                .substring(Constants.PREFIX().length() + 1).trim();\n\n        if (content.isEmpty()) {\n            channel.sendMessage(\"**Ducky** - No search query specified! - Example: `\" + Constants.PREFIX + \"g car`\");\n            return;\n        }\n\n        if (content.length() > maxcharacters) {\n            channel.sendMessage(\"**Ducky** - The character limit is `\" + maxcharacters + \"` characters.\");\n            return;\n        }\n\n        formatted = URLEncoder.encode(content, StandardCharsets.UTF_8);\n\n        search = new StringBuilder()\n                .append(Constants.SCRAPEURL())\n                .append(formatted)\n                .toString();\n\n        try {\n                Document doc = Jsoup.connect(search)\n                        //.proxy(Constants.PROXYHOST(), Constants.PROXYPORT)\n                        .get();\n\n                Element linksElement = doc.getElementById(\"links\");\n                if (linksElement == null) {\n                    channel.sendMessage(\"**Ducky** - No search results found!\");\n                    return;\n                }\n\n                Elements results = linksElement.getElementsByClass(\"results_links\");\n\n                if (results.isEmpty()) {\n                    channel.sendMessage(\"**Ducky** - No search results found!\");\n                    return;\n                }\n\n                for (int i = 0, resultsSize = results.size(); i < resultsSize; i++) {\n\n                    Element result = results.get(i);\n\n                    Element linksMain = result.getElementsByClass(\"links_main\").first();\n                    if (linksMain == null) {\n                        continue;\n                    }\n\n                    Element title = linksMain.getElementsByTag(\"a\").first();\n                    if (title == null || !title.hasText()) {\n                        channel.sendMessage(\"**Ducky** - No search results found!\");\n                        break;\n                    }\n\n                    Element desc = result.getElementsByClass(\"result__snippet\").first();\n                    \n                    String descText = (desc == null) ? \"Unable to read the description.\" : desc.text().replaceAll(\"@\", \"@-\");\n                    \n                    new MessageBuilder()\n                            .append(\"**Ducky** - `\" + message.getAuthor().getName() + \"`'s search:\")\n                            .append(\"\\n**Title** - \" + title.text().replaceAll(\"@\", \"@-\"))\n                            .append(\"\\n**Description** - \" +  descText)\n                            .append(\"\\n**Link** - \" + \"<\" + title.attr(\"href\") + \">\") // Don't show previews\n\n                    .send(channel);\n                    break;\n                }\n            } catch (IOException e) {\n                logger.warn(e);\n                logger.info(message.getAuthor());\n                channel.sendMessage(\"**Ducky** - The search parameters aren't valid.\");\n                return; // If the url isn't valid do not try to run the rest of the code.\n            } catch (NullPointerException e) {\n                logger.warn(\"Null pointer during search parsing\", e);\n                channel.sendMessage(\"**Ducky** - Failed to parse search results.\");\n                return;\n            }\n        logger.info(message.getAuthor().getId() + \" : (\" + content + \") in \" + channel.getId());\n    }\n}\n","size_bytes":5666},"src/main/java/com/github/koxsosen/Constants.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen;\n\npublic final class Constants {\n\n    public static final String PREFIX = \"/\"; // Prefix\n\n    public static final String TOKEN = System.getenv(\"DISCORD_TOKEN\"); // This is the loc of the token\n\n    public static final String STATUS = \"ERLC\"; // Status\n\n    public static final String STATUSTYPE = \"PLAYING\"; // WATCHING / PLAYING\n\n    public static final String PASTEURL = \"\"; // Paste url\n\n    public static final String SCRAPEURL = \"https://www.google.com/search?q=\"; // The url to scrape\n\n    public static final String ISSAFESEARCH = \"\"; // &kp=1\n\n    public static final String ADVERTS = \"\";\n\n    public static final String PROXYHOST = \"localhost\"; // Proxy ip: eg 172.0.0.1\n\n    public static final Integer PROXYPORT = 8080; // Proxy port. It's an integer, must be a value. eg 8080 or 8888\n\n    public Constants() { }\n\n    public static String TOKEN() {\n        return TOKEN;\n    }\n\n    public static String STATUS() {\n        return STATUS;\n    }\n\n    public static String PREFIX() {\n        return PREFIX;\n    }\n\n    public static String STATUSTYPE() {\n        return STATUSTYPE;\n    }\n\n    public static String PASTEURL() {\n        return PASTEURL;\n    }\n\n    public static String SCRAPEURL() {\n        return SCRAPEURL;\n    }\n\n    public static String PROXYHOST() {\n        return PROXYHOST;\n    }\n\n    public static Integer PROXYPORT() {\n        return PROXYPORT;\n    }\n\n    public static String ISSAFESERACH() { // could be an integer but meh\n        return ISSAFESEARCH;\n    }\n\n    public static String ADVERTS() {\n        return ADVERTS;\n    }\n\n}","size_bytes":2308},"src/main/java/com/github/koxsosen/commands/CatCommand.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.commands;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\n\nimport org.json.JSONArray;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\n\npublic class CatCommand implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(CatCommand.class);\n\n    @Command(aliases = {Constants.PREFIX + \"cat\", Constants.PREFIX + \"\\uD83D\\uDC31\"}, async = true, description = \"Get a random cat image from the web\")\n    public void onCommand(TextChannel channel, Message message) {\n\n        String catimageUrl = \"**Ducky** - No cats were found.\";\n\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(\"https://api.thecatapi.com/v1/images/search\").openConnection();\n            con.setRequestMethod(\"GET\");\n\n            BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream(), StandardCharsets.UTF_8));\n            String s = br.readLine();\n\n            if (s != null && s.length() > 0) {\n                JSONArray jsonArray = new JSONArray(s.trim());\n                catimageUrl = jsonArray.getJSONObject(0).getString(\"url\");\n            }\n\n        } catch (IOException e) {\n            logger.warn(\"Failed to fetch cat image\", e);\n        } catch (org.json.JSONException e) {\n            logger.warn(\"Failed to parse cat API response\", e);\n        } catch (Exception e) {\n            logger.error(\"Unexpected error in cat command\", e);\n        }\n        channel.sendMessage(catimageUrl);\n        logger.info(message.getAuthor());\n    }\n}\n\n","size_bytes":2648},"src/main/java/com/github/koxsosen/debug/DebugCommand.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.debug;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.DiscordApi;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\nimport org.javacord.api.entity.message.MessageBuilder;\n\nimport java.util.concurrent.TimeUnit;\n\n\npublic class DebugCommand implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(DebugCommand.class);\n\n    private final long startTime = System.currentTimeMillis();\n\n    @Command(aliases = {Constants.PREFIX +\"debug\"}, async = true, description = \"Debug command for ducky\")\n    public void onCommand(TextChannel channel, Message message, DiscordApi api) {\n        if (!message.getAuthor().isBotOwner()) {\n            channel.sendMessage(\"**Ducky** - You can't use this command.\");\n            return;\n        }\n\n        long ms = System.currentTimeMillis() - startTime;\n        long days = TimeUnit.MILLISECONDS.toDays(ms);\n        ms -= TimeUnit.DAYS.toMillis(days);\n        long hours = TimeUnit.MILLISECONDS.toHours(ms);\n        ms -= TimeUnit.HOURS.toMillis(hours);\n        long minutes = TimeUnit.MILLISECONDS.toMinutes(ms);\n        ms -= TimeUnit.MINUTES.toMillis(minutes);\n        long seconds = TimeUnit.MILLISECONDS.toSeconds(ms);\n\n        int maxmem = 1024*1024;\n\n        new MessageBuilder()\n                .append(\"**Ducky** - Debug Information:\")\n                .append(\"\\n \\n Uptime: `\"+ days + \"` d `\" + hours + \"` h `\" + minutes + \"` m `\" +   seconds  +  \"` s\" + \".\")\n                .append(\"\\n Used Memory: `\" + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory())/maxmem + \"` mb.\")\n                .append(\"\\n Servers: `\" + api.getServers().size() + \"`\")\n                .send(channel);\n\n        logger.info(message.getAuthor());\n    }\n}","size_bytes":2704},"src/main/java/com/github/koxsosen/commands/InviteCommand.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.commands;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\nimport org.javacord.api.entity.message.MessageBuilder;\nimport org.javacord.api.entity.permission.PermissionType;\nimport org.javacord.api.entity.permission.PermissionsBuilder;\n\n\npublic class InviteCommand implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(InviteCommand.class);\n\n    @Command(aliases = {Constants.PREFIX + \"inv\", Constants.PREFIX + \"invite\"}, async = true, description = \"Create an invite for Ducky\")\n    public void onCommand(TextChannel channel, Message message) {\n\n        new MessageBuilder()\n                .append(\"**Ducky** - You can invite the bot using the following url:\")\n                .append(\"\\n\" + \"<\")\n                .append(message.getApi().createBotInvite(new PermissionsBuilder().setAllowed(\n                        PermissionType.MANAGE_CHANNELS,\n                        PermissionType.SEND_MESSAGES,\n                        PermissionType.READ_MESSAGE_HISTORY)\n                        .build()))\n                .append(\">\")\n                .send(channel);\n\n        logger.info(message.getAuthor());\n    }\n}\n","size_bytes":2151},"src/main/java/com/github/koxsosen/commands/DuckCommand.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.commands;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class DuckCommand implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(DuckCommand.class);\n\n    @Command(aliases = {Constants.PREFIX + \"duck\", Constants.PREFIX + \"\\uD83E\\uDD86\"}, async = true, description = \"Get a random duck image from the web\")\n    public void onCommand(TextChannel channel, Message message) {\n\n        AtomicReference <String> imageUrl = new AtomicReference <>(\"**Ducky** - No ducks were found!\");\n\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(\"https://random-d.uk/api/v2/random\").openConnection();\n            con.setRequestMethod(\"GET\");\n\n            BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream(), StandardCharsets.UTF_8));\n            String s = br.readLine();\n\n            if (s != null && s.length() > 0) {\n                JSONObject jsonObject = new JSONObject(s.trim());\n                imageUrl.set(jsonObject.getString(\"url\"));\n            }\n\n        } catch (IOException e) {\n            logger.warn(\"Failed to fetch duck image\", e);\n        } catch (org.json.JSONException e) {\n            logger.warn(\"Failed to parse duck API response\", e);\n        } catch (Exception e) {\n            logger.error(\"Unexpected error in duck command\", e);\n        }\n        channel.sendMessage(imageUrl.get());\n        logger.info(message.getAuthor());\n    }\n}\n","size_bytes":2727},"src/main/java/com/github/koxsosen/Main.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen;\n\nimport de.btobastian.sdcf4j.CommandHandler;\nimport com.github.koxsosen.listeners.DuckyMSG;\nimport com.github.koxsosen.listeners.SlashCommandListener;\nimport com.github.koxsosen.debug.DebugCommand;\nimport com.github.koxsosen.commands.WebSearch;\nimport com.github.koxsosen.commands.CatCommand;\nimport com.github.koxsosen.commands.DogCommand;\nimport com.github.koxsosen.commands.DuckCommand;\nimport com.github.koxsosen.commands.HelpCommand;\nimport com.github.koxsosen.commands.InviteCommand;\nimport com.github.koxsosen.commands.PasteCommand;\nimport com.github.koxsosen.commands.WebsiteCommand;\nimport com.github.koxsosen.commands.EmbedCommand;\nimport com.github.koxsosen.commands.MuteCommand;\nimport com.github.koxsosen.commands.KickCommand;\nimport com.github.koxsosen.commands.BanCommand;\nimport de.btobastian.sdcf4j.handler.JavacordHandler;\nimport org.javacord.api.DiscordApiBuilder;\nimport org.javacord.api.DiscordApi;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport org.javacord.api.entity.activity.ActivityType;\nimport org.javacord.api.entity.intent.Intent;\nimport org.javacord.api.util.logging.FallbackLoggerConfiguration;\nimport org.javacord.api.interaction.SlashCommand;\nimport org.javacord.api.interaction.SlashCommandOption;\nimport org.javacord.api.interaction.SlashCommandOptionType;\nimport org.javacord.api.entity.permission.PermissionType;\n\nimport java.util.Arrays;\n\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Main {\n\n    private static final Logger logger = LogManager.getLogger(Main.class);\n\n    public static void main(String[] args) {\n\n        FallbackLoggerConfiguration.setDebug(false);\n\n        DiscordApi api = new DiscordApiBuilder()\n                .setToken(Constants.TOKEN)\n                .setWaitForServersOnStartup(false)\n                .setAllNonPrivilegedIntentsExcept(\n                        Intent.GUILD_EMOJIS,\n                        Intent.GUILD_BANS,\n                        Intent.GUILD_INVITES,\n                        Intent.DIRECT_MESSAGES,\n                        Intent.GUILD_INTEGRATIONS,\n                        Intent.GUILD_WEBHOOKS,\n                        Intent.DIRECT_MESSAGE_REACTIONS,\n                        Intent.DIRECT_MESSAGE_TYPING,\n                        Intent.GUILD_MESSAGE_TYPING,\n                        Intent.GUILD_VOICE_STATES) // Disable unneeded Intents.\n                .login().join();\n                // If the bot disconnects always reconnect with a 2*sec delay. ( 1st: 2s, 2nd:4s )\n                api.setReconnectDelay(attempt -> attempt * 2);\n                // Only cache 10 messages per channel & remove ones older than 15 min.\n                api.setMessageCacheSize(10, 30*30);\n        \n        // Rotating status setup\n        String[][] statuses = {\n            {\"PLAYING\", \"ERLC\"},\n            {\"WATCHING\", \"Members\"},\n            {\"WATCHING\", \"Bob\"},\n            {\"PLAYING\", \"Made by Mikey\"}\n        };\n        \n        AtomicInteger statusIndex = new AtomicInteger(0);\n        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n        \n        scheduler.scheduleAtFixedRate(() -> {\n            int index = statusIndex.getAndIncrement() % statuses.length;\n            String type = statuses[index][0];\n            String status = statuses[index][1];\n            api.updateActivity(ActivityType.valueOf(type), status);\n            logger.info(\"Updated status to: \" + type + \" \" + status);\n        }, 0, 10, TimeUnit.SECONDS);\n\n        // Register commands\n        CommandHandler handler = new JavacordHandler(api);\n        handler.registerCommand(new WebsiteCommand());\n        handler.registerCommand(new InviteCommand());\n        handler.registerCommand(new PasteCommand());\n        handler.registerCommand(new HelpCommand());\n        handler.registerCommand(new WebSearch());\n        handler.registerCommand(new CatCommand());\n        handler.registerCommand(new DuckCommand());\n        handler.registerCommand(new DogCommand());\n        handler.registerCommand(new DebugCommand());\n        handler.registerCommand(new EmbedCommand());\n        handler.registerCommand(new MuteCommand());\n        handler.registerCommand(new KickCommand());\n        handler.registerCommand(new BanCommand());\n\n        api.addMessageCreateListener(new DuckyMSG(handler));\n        \n        // Add slash command listener\n        api.addSlashCommandCreateListener(new SlashCommandListener());\n\n        // Register Slash Commands\n        logger.info(\"Registering slash commands...\");\n        \n        SlashCommand.with(\"mute\", \"Mute a user in voice for a specified time\",\n            Arrays.asList(\n                SlashCommandOption.create(SlashCommandOptionType.USER, \"user\", \"The user to mute\", true),\n                SlashCommandOption.create(SlashCommandOptionType.STRING, \"time\", \"Duration (e.g., 10m, 2h, 1d)\", true)\n            ))\n            .createGlobal(api)\n            .join();\n\n        SlashCommand.with(\"kick\", \"Kick a user from the server\",\n            Arrays.asList(\n                SlashCommandOption.create(SlashCommandOptionType.USER, \"user\", \"The user to kick\", true),\n                SlashCommandOption.create(SlashCommandOptionType.STRING, \"reason\", \"Reason for kick\", false)\n            ))\n            .createGlobal(api)\n            .join();\n\n        SlashCommand.with(\"ban\", \"Ban a user from the server\",\n            Arrays.asList(\n                SlashCommandOption.create(SlashCommandOptionType.USER, \"user\", \"The user to ban\", true),\n                SlashCommandOption.create(SlashCommandOptionType.STRING, \"reason\", \"Reason for ban\", false)\n            ))\n            .createGlobal(api)\n            .join();\n\n        SlashCommand.with(\"embed\", \"Create a custom embed message\",\n            Arrays.asList(\n                SlashCommandOption.create(SlashCommandOptionType.STRING, \"title\", \"Embed title\", true),\n                SlashCommandOption.create(SlashCommandOptionType.STRING, \"description\", \"Embed description\", false)\n            ))\n            .createGlobal(api)\n            .join();\n\n        logger.info(\"Slash commands registered!\");\n        logger.info(\"The bots prefix is \" + Constants.PREFIX());\n        logger.info(\"Bot is using rotating status (ERLC, Members, Bob, Made by Mikey) every 10 seconds\");\n        logger.info(\"Logged in as \" + api.getYourself() + \".\");\n        }\n\n}","size_bytes":7251},"src/main/java/com/github/koxsosen/commands/PasteCommand.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.commands;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\n\n\npublic class PasteCommand implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(PasteCommand.class);\n\n    @Command(aliases = {Constants.PREFIX +\"paste\"}, async = true, description = \"Shows Ducky's paste\")\n    public void onCommand(TextChannel channel, Message message) {\n\n       channel.sendMessage(\"**Ducky** - Hello! :wave: \" +\n               \"\\nPlease use a paste service: \" + Constants.PASTEURL());\n        logger.info(message.getAuthor());\n    }\n}","size_bytes":1555},"src/main/java/com/github/koxsosen/commands/WebsiteCommand.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.commands;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\nimport org.javacord.api.entity.message.MessageBuilder;\n\n\npublic class WebsiteCommand implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(WebsiteCommand.class);\n\n    @Command(aliases = {Constants.PREFIX + \"site\", Constants.PREFIX + \"website\"}, async = true, description = \"Shows Ducky's site\")\n    public void onCommand(TextChannel channel, Message message) {\n\n        new MessageBuilder()\n                .append(\"Ducky has it's own website!\")\n                .append(\"\\nLink: https://ducky.hahota.net\")\n               // .append(\"\\n\\n\" + \"The bot's source code can be found here:\") Remove source code mention.\n               // .append(\"\\n\" + \"<https://github.com/KoxSosen/Ducky>\")\n                .send(channel);\n\n        logger.info(message.getAuthor());\n    }\n}\n","size_bytes":1869},"src/main/java/com/github/koxsosen/commands/DogCommand.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.commands;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\nimport org.json.JSONArray;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\n\npublic class DogCommand implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(DogCommand.class);\n\n    @Command(aliases = {Constants.PREFIX + \"dog\", Constants.PREFIX + \"\\uD83D\\uDC36\"}, async = true, description = \"Get a random dog image from the web\")\n    public void onCommand(TextChannel channel, Message message) {\n\n        String dogimageUrl = \"**Ducky** - No dogs were found!\";\n\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(\"https://api.thedogapi.com/v1/images/search\").openConnection();\n            con.setRequestMethod(\"GET\");\n\n            BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream(), StandardCharsets.UTF_8));\n            String s = br.readLine();\n\n            if (s != null && s.length() > 0) {\n                JSONArray jsonArray = new JSONArray(s.trim());\n                dogimageUrl = jsonArray.getJSONObject(0).getString(\"url\");\n            }\n\n        } catch (IOException e) {\n            logger.warn(\"Failed to fetch dog image\", e);\n        } catch (org.json.JSONException e) {\n            logger.warn(\"Failed to parse dog API response\", e);\n        } catch (Exception e) {\n            logger.error(\"Unexpected error in dog command\", e);\n        }\n        channel.sendMessage(dogimageUrl);\n        logger.info(message.getAuthor());\n    }\n}\n","size_bytes":2646},"README.md":{"content":"# Discord Webhook Message Sender\n\nA web application that sends Discord messages with custom server branding (name and icon) through webhooks.\n\n## Features\n\n- üé® Send colored embed messages (Red, Green, Blue, Yellow, Purple, Orange)\n- üñºÔ∏è Automatically uses the server's name and icon as the webhook identity\n- üåê Simple web interface - no bot needed in your server\n- üîí Secure - uses webhooks created by you\n\n## Setup\n\n1. **Create a Webhook in Discord:**\n   - Right-click the channel where you want to send messages\n   - Go to `Integrations` ‚Üí `Webhooks` ‚Üí `New Webhook`\n   - Copy the webhook URL\n\n2. **Get a Server Invite Link:**\n   - Create an invite link for your Discord server\n   - This is used to fetch the server's name and icon\n\n3. **Run the Application:**\n   - Click the Run button\n   - Open the web interface\n   - Fill in the form with:\n     - Server Invite Link (e.g., `https://discord.gg/xxxxx`)\n     - Webhook URL (from step 1)\n     - Your message\n     - Color preference\n\n## How It Works\n\n1. You provide a server invite link to get the server's branding\n2. The app fetches the server name and icon from Discord's API\n3. Your message is sent through the webhook with the server's identity\n4. The message appears as a colored embed with the server's name and icon\n\n## Requirements\n\n- Node.js 20+\n- A Discord webhook URL\n- A Discord server invite link\n\n## Technologies Used\n\n- Express.js for the backend server\n- Discord API v10 for fetching server information\n- Vanilla JavaScript for the frontend\n\n## Privacy & Security\n\n- No data is stored\n- Webhook URLs are only used for sending messages\n- Server information is fetched in real-time from public invite links\n","size_bytes":1688},"src/main/java/com/github/koxsosen/commands/BanCommand.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.commands;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\nimport org.javacord.api.entity.user.User;\n\npublic class BanCommand implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(BanCommand.class);\n    private static final long REQUIRED_ROLE_ID = 1350907647217635389L;\n\n    @Command(aliases = {Constants.PREFIX + \"ban\"}, async = true, description = \"Ban a user from the server\", usage = \"/ban @user <reason>\")\n    public void onCommand(TextChannel channel, Message message, String[] args) {\n\n        if (!message.getUserAuthor().isPresent()) {\n            return;\n        }\n\n        User author = message.getUserAuthor().get();\n        \n        boolean hasPermission = message.getServer()\n            .flatMap(server -> server.getRoleById(REQUIRED_ROLE_ID))\n            .map(role -> author.getRoles(message.getServer().get()).contains(role))\n            .orElse(false);\n\n        if (!hasPermission) {\n            channel.sendMessage(\"‚ùå You don't have permission to use this command!\");\n            logger.info(author.getDiscriminatedName() + \" tried to use ban command without permission\");\n            return;\n        }\n\n        if (message.getMentionedUsers().isEmpty()) {\n            channel.sendMessage(\"‚ùå Please mention a user to ban!\");\n            return;\n        }\n\n        User targetUser = message.getMentionedUsers().get(0);\n        String reason = args.length > 1 ? String.join(\" \", java.util.Arrays.copyOfRange(args, 1, args.length)) : \"No reason provided\";\n\n        message.getServer().ifPresent(server -> {\n            server.banUser(targetUser, java.time.Duration.ofDays(0), reason).thenAccept(v -> {\n                channel.sendMessage(\"‚úÖ Banned \" + targetUser.getDiscriminatedName() + \" | Reason: \" + reason);\n                logger.info(author.getDiscriminatedName() + \" banned \" + targetUser.getDiscriminatedName() + \" for: \" + reason);\n            }).exceptionally(e -> {\n                channel.sendMessage(\"‚ùå Failed to ban user: \" + e.getMessage());\n                return null;\n            });\n        });\n    }\n}\n","size_bytes":3089},"replit.md":{"content":"# Los Angeles Roleplay Bot\n\nA feature-rich Discord bot built with Java 17 and Javacord for the Los Angeles Roleplay server.\n\n## Overview\n\nThis Discord bot provides utility commands, fun features, and moderation tools for server management. Originally based on \"Ducky\" bot, it has been customized for the Los Angeles Roleplay community.\n\n## Recent Changes (October 13, 2025)\n\n### Bot Prefix Changed\n- Changed from `!` to `/` for all commands\n\n### New Moderation Commands\nAdded three role-restricted moderation commands (requires role ID: 1350907647217635389):\n- **Mute Command** (`/mute @user <time>`): Voice mutes a user for a specified duration with automatic unmute\n  - Supports time formats: s (seconds), m (minutes), h (hours), d (days)\n  - Example: `/mute @user 10m`\n- **Kick Command** (`/kick @user <reason>`): Kicks a user from the server\n- **Ban Command** (`/ban @user <reason>`): Bans a user from the server\n\n### Updated Features\n- Help command now pings role ID 1350907647217635389\n- Help command updated to show new moderation commands\n- Embed command added with hex color #005A9C\n\n## Bot Configuration\n\n### Environment Variables\n- `DISCORD_TOKEN`: Bot token from Discord Developer Portal\n- `DISCORD_CLIENT_ID`: Application client ID\n\n### Bot Features\n- **Rotating Status**: Cycles between \"Playing ERLC\", \"Watching bob\", and \"Watching members\" every 10 seconds\n- **Command Prefix**: `/`\n- **Embed Color**: #005A9C\n\n## Available Commands\n\n### General Commands\n- `/help` or `/halp` - Shows available commands (pings moderator role)\n- `/embed <title> | <description>` - Creates a custom embed with #005A9C color\n- `/g <query>` - Web search using Google\n- `/cat` - Random cat image\n- `/duck` or `ü¶Ü` - Random duck image\n- `/dog` or `üê∂` - Random dog image\n- `/paste` - Self-hosted paste server\n- `/site` or `/website` - Bot's website\n- `/inv` or `/invite` - Invite the bot\n\n### Moderation Commands (Role Restricted: 1350907647217635389)\n- `/mute @user <time>` - Voice mute user for specified duration (e.g., 10m, 2h, 1d)\n- `/kick @user <reason>` - Kick user from server\n- `/ban @user <reason>` - Ban user from server\n\n### Debug Command\n- `/debug` - Debug information\n\n## Project Architecture\n\n### Technology Stack\n- **Language**: Java 17\n- **Discord Library**: Javacord 3.4.0\n- **Build Tool**: Gradle 7.3.3\n- **Command Framework**: SDCF4J 1.0.10\n- **Logging**: Log4j 2.17.1\n\n### Key Files\n- `src/main/java/com/github/koxsosen/Main.java` - Main bot entry point with rotating status\n- `src/main/java/com/github/koxsosen/Constants.java` - Bot configuration constants\n- `src/main/java/com/github/koxsosen/commands/` - Command implementations\n  - `MuteCommand.java` - Voice mute with scheduled unmute\n  - `KickCommand.java` - Kick functionality\n  - `BanCommand.java` - Ban functionality\n  - `EmbedCommand.java` - Custom embed creation\n  - `HelpCommand.java` - Help command with role ping\n  - Other utility commands (WebSearch, Cat, Dog, Duck, etc.)\n\n### Build Configuration\n- JVM Args: `-Xms1G -Xmx1G -XX:+UseG1GC`\n- Async logging via Log4j2\n\n## User Preferences\n\n### Moderation Setup\n- Role-based permissions using role ID: 1350907647217635389\n- Only users with this role can use moderation commands\n- Mute command includes automatic unmute scheduling\n- Clear error messages for permission issues\n\n### Design Choices\n- Prefix changed to `/` for better Discord slash command compatibility feel\n- Rotating status to show bot activity and server engagement\n- Embed color #005A9C matches server branding\n- Voice mute implementation due to Javacord 3.4.0 limitations (text timeout requires 3.8.0+)\n\n## Known Limitations\n\n- Mute command only works for voice channels (Javacord 3.4.0 doesn't support Discord's text timeout API)\n- User must be in a voice channel for mute command to work\n- Scheduled unmutes persist only while bot is running (restarts clear scheduled tasks)\n","size_bytes":3875},"src/main/java/com/github/koxsosen/commands/MuteCommand.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.commands;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\nimport org.javacord.api.entity.user.User;\n\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MuteCommand implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(MuteCommand.class);\n    private static final long REQUIRED_ROLE_ID = 1350907647217635389L;\n    private static final Pattern TIME_PATTERN = Pattern.compile(\"(\\\\d+)([smhd])\");\n    private static final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\n    @Command(aliases = {Constants.PREFIX + \"mute\"}, async = true, description = \"Mute a user for a specified time\", usage = \"/mute @user <time>\")\n    public void onCommand(TextChannel channel, Message message, String[] args) {\n\n        if (!message.getUserAuthor().isPresent()) {\n            return;\n        }\n\n        User author = message.getUserAuthor().get();\n        \n        boolean hasPermission = message.getServer()\n            .flatMap(server -> server.getRoleById(REQUIRED_ROLE_ID))\n            .map(role -> author.getRoles(message.getServer().get()).contains(role))\n            .orElse(false);\n\n        if (!hasPermission) {\n            channel.sendMessage(\"‚ùå You don't have permission to use this command!\");\n            logger.info(author.getDiscriminatedName() + \" tried to use mute command without permission\");\n            return;\n        }\n\n        if (args.length < 2) {\n            channel.sendMessage(\"Usage: `/mute @user <time>`\\nExample: `/mute @user 10m` (s=seconds, m=minutes, h=hours, d=days)\");\n            return;\n        }\n\n        if (message.getMentionedUsers().isEmpty()) {\n            channel.sendMessage(\"‚ùå Please mention a user to mute!\");\n            return;\n        }\n\n        User targetUser = message.getMentionedUsers().get(0);\n        String timeString = args[1].toLowerCase();\n\n        Long delaySeconds = parseTimeToSeconds(timeString);\n        if (delaySeconds == null) {\n            channel.sendMessage(\"‚ùå Invalid time format! Use: 10s, 5m, 2h, or 1d\");\n            return;\n        }\n\n        message.getServer().ifPresent(server -> {\n            server.muteUser(targetUser).thenAccept(v -> {\n                channel.sendMessage(\"‚úÖ Voice muted \" + targetUser.getMentionTag() + \" for \" + timeString + \" (they must be in a voice channel)\");\n                logger.info(author.getDiscriminatedName() + \" muted \" + targetUser.getDiscriminatedName() + \" for \" + timeString);\n                \n                scheduler.schedule(() -> {\n                    server.unmuteUser(targetUser).thenAccept(unmuted -> {\n                        channel.sendMessage(\"üîä \" + targetUser.getMentionTag() + \" has been automatically unmuted\");\n                        logger.info(\"Auto-unmuted \" + targetUser.getDiscriminatedName() + \" after \" + timeString);\n                    }).exceptionally(ex -> {\n                        logger.error(\"Failed to auto-unmute \" + targetUser.getDiscriminatedName() + \": \" + ex.getMessage());\n                        return null;\n                    });\n                }, delaySeconds, TimeUnit.SECONDS);\n                \n            }).exceptionally(e -> {\n                channel.sendMessage(\"‚ùå Failed to mute user. Make sure the bot has proper permissions and the user is in a voice channel.\");\n                logger.error(\"Failed to mute user: \" + e.getMessage());\n                return null;\n            });\n        });\n    }\n\n    private Long parseTimeToSeconds(String timeString) {\n        Matcher matcher = TIME_PATTERN.matcher(timeString);\n        if (!matcher.matches()) {\n            return null;\n        }\n\n        long value = Long.parseLong(matcher.group(1));\n        String unit = matcher.group(2);\n\n        switch (unit) {\n            case \"s\":\n                return value;\n            case \"m\":\n                return value * 60;\n            case \"h\":\n                return value * 3600;\n            case \"d\":\n                return value * 86400;\n            default:\n                return null;\n        }\n    }\n}\n\n","size_bytes":5202},"src/main/java/com/github/koxsosen/listeners/SlashCommandListener.java":{"content":"package com.github.koxsosen.listeners;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.event.interaction.SlashCommandCreateEvent;\nimport org.javacord.api.interaction.SlashCommandInteraction;\nimport org.javacord.api.listener.interaction.SlashCommandCreateListener;\nimport org.javacord.api.entity.user.User;\nimport org.javacord.api.entity.message.embed.EmbedBuilder;\n\nimport java.awt.Color;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class SlashCommandListener implements SlashCommandCreateListener {\n\n    private static final Logger logger = LogManager.getLogger(SlashCommandListener.class);\n    private static final long REQUIRED_ROLE_ID = 1350907647217635389L;\n    private static final Pattern TIME_PATTERN = Pattern.compile(\"(\\\\d+)([smhd])\");\n    private static final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\n    @Override\n    public void onSlashCommandCreate(SlashCommandCreateEvent event) {\n        SlashCommandInteraction interaction = event.getSlashCommandInteraction();\n        String commandName = interaction.getCommandName();\n\n        switch (commandName) {\n            case \"mute\":\n                handleMuteCommand(interaction);\n                break;\n            case \"kick\":\n                handleKickCommand(interaction);\n                break;\n            case \"ban\":\n                handleBanCommand(interaction);\n                break;\n            case \"embed\":\n                handleEmbedCommand(interaction);\n                break;\n        }\n    }\n\n    private void handleMuteCommand(SlashCommandInteraction interaction) {\n        User author = interaction.getUser();\n        \n        boolean hasPermission = interaction.getServer()\n            .flatMap(server -> server.getRoleById(REQUIRED_ROLE_ID))\n            .map(role -> author.getRoles(interaction.getServer().get()).contains(role))\n            .orElse(false);\n\n        if (!hasPermission) {\n            interaction.createImmediateResponder()\n                .setContent(\"‚ùå You don't have permission to use this command!\")\n                .respond();\n            logger.info(author.getDiscriminatedName() + \" tried to use mute command without permission\");\n            return;\n        }\n\n        User targetUser = interaction.getArgumentUserValueByName(\"user\").orElse(null);\n        String timeString = interaction.getArgumentStringValueByName(\"time\").orElse(\"\");\n\n        if (targetUser == null) {\n            interaction.createImmediateResponder()\n                .setContent(\"‚ùå Please mention a user to mute!\")\n                .respond();\n            return;\n        }\n\n        Long delaySeconds = parseTimeToSeconds(timeString.toLowerCase());\n        if (delaySeconds == null) {\n            interaction.createImmediateResponder()\n                .setContent(\"‚ùå Invalid time format! Use: 10s, 5m, 2h, or 1d\")\n                .respond();\n            return;\n        }\n\n        interaction.getServer().ifPresent(server -> {\n            server.muteUser(targetUser).thenAccept(v -> {\n                interaction.createImmediateResponder()\n                    .setContent(\"‚úÖ Voice muted \" + targetUser.getMentionTag() + \" for \" + timeString + \" (they must be in a voice channel)\")\n                    .respond();\n                logger.info(author.getDiscriminatedName() + \" muted \" + targetUser.getDiscriminatedName() + \" for \" + timeString);\n                \n                scheduler.schedule(() -> {\n                    server.unmuteUser(targetUser).thenAccept(unmuted -> {\n                        interaction.getChannel().ifPresent(channel -> \n                            channel.sendMessage(\"üîä \" + targetUser.getMentionTag() + \" has been automatically unmuted\")\n                        );\n                        logger.info(\"Auto-unmuted \" + targetUser.getDiscriminatedName() + \" after \" + timeString);\n                    }).exceptionally(ex -> {\n                        logger.error(\"Failed to auto-unmute \" + targetUser.getDiscriminatedName() + \": \" + ex.getMessage());\n                        return null;\n                    });\n                }, delaySeconds, TimeUnit.SECONDS);\n                \n            }).exceptionally(e -> {\n                interaction.createImmediateResponder()\n                    .setContent(\"‚ùå Failed to mute user. Make sure the bot has proper permissions and the user is in a voice channel.\")\n                    .respond();\n                logger.error(\"Failed to mute user: \" + e.getMessage());\n                return null;\n            });\n        });\n    }\n\n    private void handleKickCommand(SlashCommandInteraction interaction) {\n        User author = interaction.getUser();\n        \n        boolean hasPermission = interaction.getServer()\n            .flatMap(server -> server.getRoleById(REQUIRED_ROLE_ID))\n            .map(role -> author.getRoles(interaction.getServer().get()).contains(role))\n            .orElse(false);\n\n        if (!hasPermission) {\n            interaction.createImmediateResponder()\n                .setContent(\"‚ùå You don't have permission to use this command!\")\n                .respond();\n            logger.info(author.getDiscriminatedName() + \" tried to use kick command without permission\");\n            return;\n        }\n\n        User targetUser = interaction.getArgumentUserValueByName(\"user\").orElse(null);\n        String reason = interaction.getArgumentStringValueByName(\"reason\").orElse(\"No reason provided\");\n\n        if (targetUser == null) {\n            interaction.createImmediateResponder()\n                .setContent(\"‚ùå Please mention a user to kick!\")\n                .respond();\n            return;\n        }\n\n        interaction.getServer().ifPresent(server -> {\n            server.kickUser(targetUser, reason).thenAccept(v -> {\n                interaction.createImmediateResponder()\n                    .setContent(\"‚úÖ Kicked \" + targetUser.getDiscriminatedName() + \" | Reason: \" + reason)\n                    .respond();\n                logger.info(author.getDiscriminatedName() + \" kicked \" + targetUser.getDiscriminatedName() + \" for: \" + reason);\n            }).exceptionally(e -> {\n                interaction.createImmediateResponder()\n                    .setContent(\"‚ùå Failed to kick user: \" + e.getMessage())\n                    .respond();\n                return null;\n            });\n        });\n    }\n\n    private void handleBanCommand(SlashCommandInteraction interaction) {\n        User author = interaction.getUser();\n        \n        boolean hasPermission = interaction.getServer()\n            .flatMap(server -> server.getRoleById(REQUIRED_ROLE_ID))\n            .map(role -> author.getRoles(interaction.getServer().get()).contains(role))\n            .orElse(false);\n\n        if (!hasPermission) {\n            interaction.createImmediateResponder()\n                .setContent(\"‚ùå You don't have permission to use this command!\")\n                .respond();\n            logger.info(author.getDiscriminatedName() + \" tried to use ban command without permission\");\n            return;\n        }\n\n        User targetUser = interaction.getArgumentUserValueByName(\"user\").orElse(null);\n        String reason = interaction.getArgumentStringValueByName(\"reason\").orElse(\"No reason provided\");\n\n        if (targetUser == null) {\n            interaction.createImmediateResponder()\n                .setContent(\"‚ùå Please mention a user to ban!\")\n                .respond();\n            return;\n        }\n\n        interaction.getServer().ifPresent(server -> {\n            server.banUser(targetUser, java.time.Duration.ofDays(0), reason).thenAccept(v -> {\n                interaction.createImmediateResponder()\n                    .setContent(\"‚úÖ Banned \" + targetUser.getDiscriminatedName() + \" | Reason: \" + reason)\n                    .respond();\n                logger.info(author.getDiscriminatedName() + \" banned \" + targetUser.getDiscriminatedName() + \" for: \" + reason);\n            }).exceptionally(e -> {\n                interaction.createImmediateResponder()\n                    .setContent(\"‚ùå Failed to ban user: \" + e.getMessage())\n                    .respond();\n                return null;\n            });\n        });\n    }\n\n    private void handleEmbedCommand(SlashCommandInteraction interaction) {\n        String title = interaction.getArgumentStringValueByName(\"title\").orElse(\"Embed\");\n        String description = interaction.getArgumentStringValueByName(\"description\").orElse(\"\");\n\n        EmbedBuilder embed = new EmbedBuilder()\n                .setTitle(title)\n                .setDescription(description)\n                .setColor(Color.decode(\"#005A9C\"));\n\n        interaction.createImmediateResponder()\n                .addEmbed(embed)\n                .respond();\n        \n        logger.info(interaction.getUser().getDiscriminatedName() + \" used embed command\");\n    }\n\n    private Long parseTimeToSeconds(String timeString) {\n        Matcher matcher = TIME_PATTERN.matcher(timeString);\n        if (!matcher.matches()) {\n            return null;\n        }\n\n        long value = Long.parseLong(matcher.group(1));\n        String unit = matcher.group(2);\n\n        switch (unit) {\n            case \"s\":\n                return value;\n            case \"m\":\n                return value * 60;\n            case \"h\":\n                return value * 3600;\n            case \"d\":\n                return value * 86400;\n            default:\n                return null;\n        }\n    }\n}\n","size_bytes":9652},"src/main/java/com/github/koxsosen/commands/KickCommand.java":{"content":"/*\nDucky - A web search utility with other features.\nCopyright (C) 2021 KoxSosen\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npackage com.github.koxsosen.commands;\n\nimport com.github.koxsosen.Constants;\nimport de.btobastian.sdcf4j.Command;\nimport de.btobastian.sdcf4j.CommandExecutor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.TextChannel;\nimport org.javacord.api.entity.message.Message;\nimport org.javacord.api.entity.user.User;\n\npublic class KickCommand implements CommandExecutor {\n\n    private static final Logger logger = LogManager.getLogger(KickCommand.class);\n    private static final long REQUIRED_ROLE_ID = 1350907647217635389L;\n\n    @Command(aliases = {Constants.PREFIX + \"kick\"}, async = true, description = \"Kick a user from the server\", usage = \"/kick @user <reason>\")\n    public void onCommand(TextChannel channel, Message message, String[] args) {\n\n        if (!message.getUserAuthor().isPresent()) {\n            return;\n        }\n\n        User author = message.getUserAuthor().get();\n        \n        boolean hasPermission = message.getServer()\n            .flatMap(server -> server.getRoleById(REQUIRED_ROLE_ID))\n            .map(role -> author.getRoles(message.getServer().get()).contains(role))\n            .orElse(false);\n\n        if (!hasPermission) {\n            channel.sendMessage(\"‚ùå You don't have permission to use this command!\");\n            logger.info(author.getDiscriminatedName() + \" tried to use kick command without permission\");\n            return;\n        }\n\n        if (message.getMentionedUsers().isEmpty()) {\n            channel.sendMessage(\"‚ùå Please mention a user to kick!\");\n            return;\n        }\n\n        User targetUser = message.getMentionedUsers().get(0);\n        String reason = args.length > 1 ? String.join(\" \", java.util.Arrays.copyOfRange(args, 1, args.length)) : \"No reason provided\";\n\n        message.getServer().ifPresent(server -> {\n            server.kickUser(targetUser, reason).thenAccept(v -> {\n                channel.sendMessage(\"‚úÖ Kicked \" + targetUser.getDiscriminatedName() + \" | Reason: \" + reason);\n                logger.info(author.getDiscriminatedName() + \" kicked \" + targetUser.getDiscriminatedName() + \" for: \" + reason);\n            }).exceptionally(e -> {\n                channel.sendMessage(\"‚ùå Failed to kick user: \" + e.getMessage());\n                return null;\n            });\n        });\n    }\n}\n","size_bytes":3068},"src/main/java/com/github/koxsosen/services/ERLCService.java":{"content":"package com.github.koxsosen.services;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.json.JSONObject;\nimport org.json.JSONArray;\n\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.CompletableFuture;\n\npublic class ERLCService {\n    private static final Logger logger = LogManager.getLogger(ERLCService.class);\n    private static final String API_BASE_URL = \"https://api.policeroleplay.community/v1\";\n    private static final String API_KEY = System.getenv(\"ERLC_API_KEY\");\n    private final HttpClient httpClient;\n    \n    private int lastPlayerCount = 0;\n    private int maxPlayers = 0;\n    \n    public ERLCService() {\n        this.httpClient = HttpClient.newBuilder().build();\n    }\n    \n    public CompletableFuture<ServerStatus> getServerStatus() {\n        if (API_KEY == null || API_KEY.isEmpty()) {\n            logger.error(\"ERLC_API_KEY environment variable is not set!\");\n            return CompletableFuture.failedFuture(new IllegalStateException(\"ERLC API key not configured\"));\n        }\n        \n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(API_BASE_URL + \"/server\"))\n            .header(\"server-key\", API_KEY)\n            .header(\"Accept\", \"*/*\")\n            .GET()\n            .build();\n        \n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n            .thenApply(response -> {\n                if (response.statusCode() == 200) {\n                    JSONObject json = new JSONObject(response.body());\n                    int currentPlayers = json.getInt(\"CurrentPlayers\");\n                    int maxPlayers = json.getInt(\"MaxPlayers\");\n                    String joinKey = json.getString(\"JoinKey\");\n                    \n                    ServerStatus status = new ServerStatus(currentPlayers, maxPlayers, joinKey);\n                    logger.info(\"ERLC Server Status - Players: \" + currentPlayers + \"/\" + maxPlayers);\n                    return status;\n                } else if (response.statusCode() == 403) {\n                    logger.error(\"ERLC API authentication failed - check your API key\");\n                    throw new RuntimeException(\"ERLC API authentication failed\");\n                } else if (response.statusCode() == 429) {\n                    String retryAfter = response.headers().firstValue(\"Retry-After\").orElse(\"unknown\");\n                    logger.warn(\"ERLC API rate limit exceeded. Retry after: \" + retryAfter + \" seconds\");\n                    throw new RuntimeException(\"ERLC API rate limit exceeded\");\n                } else {\n                    logger.error(\"ERLC API request failed with status: \" + response.statusCode());\n                    throw new RuntimeException(\"ERLC API request failed: \" + response.statusCode());\n                }\n            });\n    }\n    \n    public CompletableFuture<Void> sendCommand(String command) {\n        if (API_KEY == null || API_KEY.isEmpty()) {\n            logger.error(\"ERLC_API_KEY environment variable is not set!\");\n            return CompletableFuture.failedFuture(new IllegalStateException(\"ERLC API key not configured\"));\n        }\n        \n        JSONObject body = new JSONObject();\n        body.put(\"command\", command);\n        \n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(API_BASE_URL + \"/server/command\"))\n            .header(\"server-key\", API_KEY)\n            .header(\"Content-Type\", \"application/json\")\n            .header(\"Accept\", \"*/*\")\n            .POST(HttpRequest.BodyPublishers.ofString(body.toString()))\n            .build();\n        \n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n            .thenApply(response -> {\n                if (response.statusCode() == 200) {\n                    logger.info(\"ERLC command executed successfully: \" + command);\n                    return null;\n                } else if (response.statusCode() == 422) {\n                    logger.warn(\"ERLC server has no players to execute command\");\n                    throw new RuntimeException(\"Server has no players\");\n                } else if (response.statusCode() == 403) {\n                    logger.error(\"ERLC API authentication failed\");\n                    throw new RuntimeException(\"ERLC API authentication failed\");\n                } else if (response.statusCode() == 429) {\n                    String retryAfter = response.headers().firstValue(\"Retry-After\").orElse(\"unknown\");\n                    logger.warn(\"ERLC API rate limit exceeded for command. Retry after: \" + retryAfter + \" seconds\");\n                    throw new RuntimeException(\"ERLC API rate limit exceeded\");\n                } else {\n                    logger.error(\"ERLC command failed with status: \" + response.statusCode());\n                    throw new RuntimeException(\"ERLC command failed: \" + response.statusCode());\n                }\n            });\n    }\n    \n    public int getLastPlayerCount() {\n        return lastPlayerCount;\n    }\n    \n    public void setLastPlayerCount(int count) {\n        this.lastPlayerCount = count;\n    }\n    \n    public int getMaxPlayers() {\n        return maxPlayers;\n    }\n    \n    public void setMaxPlayers(int max) {\n        this.maxPlayers = max;\n    }\n    \n    public CompletableFuture<JSONArray> getPlayers() {\n        if (API_KEY == null || API_KEY.isEmpty()) {\n            logger.error(\"ERLC_API_KEY environment variable is not set!\");\n            return CompletableFuture.failedFuture(new IllegalStateException(\"ERLC API key not configured\"));\n        }\n        \n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(API_BASE_URL + \"/server/players\"))\n            .header(\"server-key\", API_KEY)\n            .header(\"Accept\", \"*/*\")\n            .GET()\n            .build();\n        \n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n            .thenApply(response -> {\n                if (response.statusCode() == 200) {\n                    JSONArray players = new JSONArray(response.body());\n                    logger.info(\"ERLC Players fetched - Count: \" + players.length());\n                    return players;\n                } else if (response.statusCode() == 403) {\n                    logger.error(\"ERLC API authentication failed\");\n                    throw new RuntimeException(\"ERLC API authentication failed\");\n                } else if (response.statusCode() == 429) {\n                    String retryAfter = response.headers().firstValue(\"Retry-After\").orElse(\"unknown\");\n                    logger.warn(\"ERLC API rate limit exceeded. Retry after: \" + retryAfter + \" seconds\");\n                    throw new RuntimeException(\"ERLC API rate limit exceeded\");\n                } else {\n                    logger.error(\"ERLC API request failed with status: \" + response.statusCode());\n                    throw new RuntimeException(\"ERLC API request failed: \" + response.statusCode());\n                }\n            });\n    }\n    \n    public CompletableFuture<JSONArray> getQueue() {\n        if (API_KEY == null || API_KEY.isEmpty()) {\n            logger.error(\"ERLC_API_KEY environment variable is not set!\");\n            return CompletableFuture.failedFuture(new IllegalStateException(\"ERLC API key not configured\"));\n        }\n        \n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(API_BASE_URL + \"/server/queue\"))\n            .header(\"server-key\", API_KEY)\n            .header(\"Accept\", \"*/*\")\n            .GET()\n            .build();\n        \n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n            .thenApply(response -> {\n                if (response.statusCode() == 200) {\n                    JSONArray queue = new JSONArray(response.body());\n                    logger.info(\"ERLC Queue fetched - Count: \" + queue.length());\n                    return queue;\n                } else if (response.statusCode() == 403) {\n                    logger.error(\"ERLC API authentication failed\");\n                    throw new RuntimeException(\"ERLC API authentication failed\");\n                } else if (response.statusCode() == 429) {\n                    String retryAfter = response.headers().firstValue(\"Retry-After\").orElse(\"unknown\");\n                    logger.warn(\"ERLC API rate limit exceeded. Retry after: \" + retryAfter + \" seconds\");\n                    throw new RuntimeException(\"ERLC API rate limit exceeded\");\n                } else {\n                    logger.error(\"ERLC API request failed with status: \" + response.statusCode());\n                    throw new RuntimeException(\"ERLC API request failed: \" + response.statusCode());\n                }\n            });\n    }\n    \n    public static class ServerStatus {\n        public final int currentPlayers;\n        public final int maxPlayers;\n        public final String joinKey;\n        \n        public ServerStatus(int currentPlayers, int maxPlayers, String joinKey) {\n            this.currentPlayers = currentPlayers;\n            this.maxPlayers = maxPlayers;\n            this.joinKey = joinKey;\n        }\n    }\n}\n","size_bytes":9262},"src/main/java/com/github/koxsosen/services/ERLCMonitor.java":{"content":"package com.github.koxsosen.services;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.DiscordApi;\nimport org.javacord.api.entity.channel.ServerTextChannel;\nimport org.javacord.api.entity.message.embed.EmbedBuilder;\n\nimport java.awt.Color;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class ERLCMonitor {\n    private static final Logger logger = LogManager.getLogger(ERLCMonitor.class);\n    private final ERLCService erlcService;\n    private final DiscordApi api;\n    private final ScheduledExecutorService scheduler;\n    \n    private int previousPlayerCount = 0;\n    private int maxPlayers = 0;\n    private boolean hasPostedFull = false;\n    \n    public ERLCMonitor(DiscordApi api) {\n        this.api = api;\n        this.erlcService = new ERLCService();\n        this.scheduler = Executors.newScheduledThreadPool(1);\n    }\n    \n    public void startMonitoring(long sessionChannelId) {\n        logger.info(\"Starting ERLC server monitoring...\");\n        \n        // Check server status every 30 seconds\n        scheduler.scheduleAtFixedRate(() -> {\n            try {\n                erlcService.getServerStatus().thenAccept(status -> {\n                    int currentPlayers = status.currentPlayers;\n                    maxPlayers = status.maxPlayers;\n                    \n                    // Check if player count dropped to 1 (from higher count)\n                    if (currentPlayers == 1 && previousPlayerCount > 1) {\n                        postSessionLow(sessionChannelId);\n                    }\n                    \n                    // Check if server became full\n                    if (currentPlayers >= maxPlayers && !hasPostedFull) {\n                        postSessionFull(sessionChannelId);\n                        hasPostedFull = true;\n                    }\n                    \n                    // Reset full flag if players leave\n                    if (currentPlayers < maxPlayers) {\n                        hasPostedFull = false;\n                    }\n                    \n                    previousPlayerCount = currentPlayers;\n                }).exceptionally(ex -> {\n                    logger.error(\"Failed to fetch ERLC server status: \" + ex.getMessage());\n                    return null;\n                });\n            } catch (Exception e) {\n                logger.error(\"Error in ERLC monitoring loop: \" + e.getMessage());\n            }\n        }, 0, 30, TimeUnit.SECONDS);\n    }\n    \n    private void postSessionLow(long channelId) {\n        api.getServerTextChannelById(channelId).ifPresent(channel -> {\n            java.io.File lowLogoFile = new java.io.File(\"attached_assets/image_1760418560244.png\");\n            \n            EmbedBuilder lowEmbed = new EmbedBuilder()\n                .setTitle(\"üü° Los Angeles Session Activity: Low\")\n                .setDescription(\"Session activity is currently **LOW**!\\n\\nOnly 1 player remaining in the server - don't let them roleplay alone! Jump in and help make this session amazing! Your presence makes all the difference! üíô\\n\\n**Join Code:** `LARPVCOS`\")\n                .setColor(Color.decode(\"#FFFF00\"))\n                .setTimestamp(java.time.Instant.now());\n            \n            if (lowLogoFile.exists()) {\n                lowEmbed.setImage(lowLogoFile);\n            }\n            \n            // Post without deleting previous messages\n            new org.javacord.api.entity.message.MessageBuilder()\n                .setContent(\"@everyone\")\n                .setEmbed(lowEmbed)\n                .send(channel);\n            logger.info(\"Posted session LOW message - 1 player remaining\");\n        });\n    }\n    \n    private void postSessionFull(long channelId) {\n        api.getServerTextChannelById(channelId).ifPresent(channel -> {\n            java.io.File fullLogoFile = new java.io.File(\"attached_assets/image_1760418567517.png\");\n            \n            EmbedBuilder fullEmbed = new EmbedBuilder()\n                .setTitle(\"üîµ Los Angeles Session Activity: Full\")\n                .setDescription(\"Session is currently **FULL**!\\n\\nThe server has reached maximum capacity - the roleplay is absolutely buzzing right now! Keep an eye out for an open slot so you can join the action! üé≠‚ú®\\n\\n**Join Code:** `LARPVCOS`\")\n                .setColor(Color.decode(\"#0000FF\"))\n                .setTimestamp(java.time.Instant.now());\n            \n            if (fullLogoFile.exists()) {\n                fullEmbed.setImage(fullLogoFile);\n            }\n            \n            // Post without deleting previous messages\n            new org.javacord.api.entity.message.MessageBuilder()\n                .setContent(\"@everyone\")\n                .setEmbed(fullEmbed)\n                .send(channel);\n            logger.info(\"Posted session FULL message - \" + maxPlayers + \" players\");\n        });\n    }\n    \n    public void sendShutdownMessage() {\n        erlcService.sendCommand(\":h Server shutting down - kicking all players!\")\n            .thenRun(() -> logger.info(\"Sent shutdown message to ERLC server\"))\n            .exceptionally(ex -> {\n                logger.error(\"Failed to send shutdown message: \" + ex.getMessage());\n                return null;\n            });\n    }\n    \n    public void stopMonitoring() {\n        logger.info(\"Stopping ERLC server monitoring...\");\n        scheduler.shutdown();\n    }\n}\n","size_bytes":5464},"src/main/java/com/github/koxsosen/listeners/ReactionRoleListener.java":{"content":"package com.github.koxsosen.listeners;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.emoji.Emoji;\nimport org.javacord.api.entity.server.Server;\nimport org.javacord.api.entity.user.User;\nimport org.javacord.api.event.message.reaction.ReactionAddEvent;\nimport org.javacord.api.event.message.reaction.ReactionRemoveEvent;\nimport org.javacord.api.listener.message.reaction.ReactionAddListener;\nimport org.javacord.api.listener.message.reaction.ReactionRemoveListener;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class ReactionRoleListener implements ReactionAddListener, ReactionRemoveListener {\n    \n    private static final Logger logger = LogManager.getLogger(ReactionRoleListener.class);\n    \n    // Message ID -> Emoji -> Role ID\n    public static final Map<Long, Map<String, Long>> reactionRoles = new ConcurrentHashMap<>();\n    \n    static {\n        // Load reaction roles from database on startup\n        Map<Long, Map<String, Long>> loadedRoles = com.github.koxsosen.services.DatabaseService.loadAllReactionRoles();\n        reactionRoles.putAll(loadedRoles);\n        logger.info(\"Loaded \" + reactionRoles.size() + \" reaction role messages on startup\");\n    }\n    \n    @Override\n    public void onReactionAdd(ReactionAddEvent event) {\n        if (event.getUser().map(User::isBot).orElse(true)) {\n            return;\n        }\n        \n        long messageId = event.getMessageId();\n        \n        if (!reactionRoles.containsKey(messageId)) {\n            return;\n        }\n        \n        String emojiString = getEmojiString(event.getEmoji());\n        Map<String, Long> emojiRoleMap = reactionRoles.get(messageId);\n        \n        if (!emojiRoleMap.containsKey(emojiString)) {\n            return;\n        }\n        \n        long roleId = emojiRoleMap.get(emojiString);\n        \n        event.getServer().ifPresent(server -> {\n            event.getUser().ifPresent(user -> {\n                server.getRoleById(roleId).ifPresent(role -> {\n                    server.addRoleToUser(user, role).thenRun(() -> {\n                        logger.info(\"Added role \" + role.getName() + \" to \" + user.getName());\n                    }).exceptionally(e -> {\n                        logger.error(\"Failed to add role: \" + e.getMessage());\n                        return null;\n                    });\n                });\n            });\n        });\n    }\n    \n    @Override\n    public void onReactionRemove(ReactionRemoveEvent event) {\n        if (event.getUser().map(User::isBot).orElse(true)) {\n            return;\n        }\n        \n        long messageId = event.getMessageId();\n        \n        if (!reactionRoles.containsKey(messageId)) {\n            return;\n        }\n        \n        String emojiString = getEmojiString(event.getEmoji());\n        Map<String, Long> emojiRoleMap = reactionRoles.get(messageId);\n        \n        if (!emojiRoleMap.containsKey(emojiString)) {\n            return;\n        }\n        \n        long roleId = emojiRoleMap.get(emojiString);\n        \n        event.getServer().ifPresent(server -> {\n            event.getUser().ifPresent(user -> {\n                server.getRoleById(roleId).ifPresent(role -> {\n                    server.removeRoleFromUser(user, role).thenRun(() -> {\n                        logger.info(\"Removed role \" + role.getName() + \" from \" + user.getName());\n                    }).exceptionally(e -> {\n                        logger.error(\"Failed to remove role: \" + e.getMessage());\n                        return null;\n                    });\n                });\n            });\n        });\n    }\n    \n    private String getEmojiString(Emoji emoji) {\n        if (emoji.isUnicodeEmoji()) {\n            return emoji.asUnicodeEmoji().get();\n        } else if (emoji.isCustomEmoji()) {\n            return emoji.asCustomEmoji().get().getId() + \"\";\n        }\n        return \"\";\n    }\n}\n","size_bytes":3933},"src/main/java/com/github/koxsosen/services/DatabaseService.java":{"content":"package com.github.koxsosen.services;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.sql.*;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class DatabaseService {\n    \n    private static final Logger logger = LogManager.getLogger(DatabaseService.class);\n    private static Connection connection = null;\n    \n    public static void initialize() {\n        String url = System.getenv(\"DATABASE_URL\");\n        \n        if (url == null || url.isEmpty()) {\n            logger.warn(\"DATABASE_URL not set - reaction roles will not persist across restarts\");\n            return;\n        }\n        \n        try {\n            // Parse the DATABASE_URL to extract username, password, host, and database\n            // Format: postgresql://username:password@host/database?params\n            String jdbcUrl = url;\n            String username = null;\n            String password = null;\n            \n            if (url.startsWith(\"postgresql://\")) {\n                // Extract credentials\n                String urlWithoutProtocol = url.substring(\"postgresql://\".length());\n                String[] parts = urlWithoutProtocol.split(\"@\", 2);\n                \n                if (parts.length == 2) {\n                    // Extract username and password\n                    String[] credentials = parts[0].split(\":\", 2);\n                    username = credentials[0];\n                    password = credentials.length > 1 ? credentials[1] : null;\n                    \n                    // Reconstruct JDBC URL\n                    jdbcUrl = \"jdbc:postgresql://\" + parts[1];\n                }\n            } else if (!url.startsWith(\"jdbc:\")) {\n                jdbcUrl = \"jdbc:\" + url;\n            }\n            \n            if (username != null && password != null) {\n                connection = DriverManager.getConnection(jdbcUrl, username, password);\n            } else {\n                connection = DriverManager.getConnection(jdbcUrl);\n            }\n            \n            logger.info(\"Connected to PostgreSQL database\");\n            createReactionRoleTable();\n        } catch (SQLException e) {\n            logger.error(\"Failed to connect to database: \" + e.getMessage());\n        }\n    }\n    \n    private static void createReactionRoleTable() {\n        if (connection == null) return;\n        \n        String createTableSQL = \"\"\"\n            CREATE TABLE IF NOT EXISTS reaction_roles (\n                message_id BIGINT NOT NULL,\n                emoji TEXT NOT NULL,\n                role_id BIGINT NOT NULL,\n                PRIMARY KEY (message_id, emoji)\n            )\n        \"\"\";\n        \n        try (Statement stmt = connection.createStatement()) {\n            stmt.execute(createTableSQL);\n            logger.info(\"Reaction roles table ready\");\n        } catch (SQLException e) {\n            logger.error(\"Failed to create reaction_roles table: \" + e.getMessage());\n        }\n        \n        createBotConfigTable();\n        createCommandLogsTable();\n    }\n    \n    private static void createBotConfigTable() {\n        if (connection == null) return;\n        \n        String createTableSQL = \"\"\"\n            CREATE TABLE IF NOT EXISTS bot_config (\n                config_key TEXT PRIMARY KEY,\n                config_value TEXT NOT NULL\n            )\n        \"\"\";\n        \n        try (Statement stmt = connection.createStatement()) {\n            stmt.execute(createTableSQL);\n            logger.info(\"Bot config table ready\");\n        } catch (SQLException e) {\n            logger.error(\"Failed to create bot_config table: \" + e.getMessage());\n        }\n    }\n    \n    private static void createCommandLogsTable() {\n        if (connection == null) return;\n        \n        String createTableSQL = \"\"\"\n            CREATE TABLE IF NOT EXISTS command_logs (\n                id SERIAL PRIMARY KEY,\n                server_id BIGINT NOT NULL,\n                command_name TEXT NOT NULL,\n                user_id BIGINT NOT NULL,\n                username TEXT NOT NULL,\n                parameters TEXT,\n                executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\";\n        \n        try (Statement stmt = connection.createStatement()) {\n            stmt.execute(createTableSQL);\n            logger.info(\"Command logs table ready\");\n        } catch (SQLException e) {\n            logger.error(\"Failed to create command_logs table: \" + e.getMessage());\n        }\n    }\n    \n    public static void saveReactionRole(long messageId, String emoji, long roleId) {\n        if (connection == null) return;\n        \n        String insertSQL = \"INSERT INTO reaction_roles (message_id, emoji, role_id) VALUES (?, ?, ?) ON CONFLICT (message_id, emoji) DO UPDATE SET role_id = ?\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(insertSQL)) {\n            pstmt.setLong(1, messageId);\n            pstmt.setString(2, emoji);\n            pstmt.setLong(3, roleId);\n            pstmt.setLong(4, roleId);\n            pstmt.executeUpdate();\n            logger.debug(\"Saved reaction role: message=\" + messageId + \", emoji=\" + emoji + \", role=\" + roleId);\n        } catch (SQLException e) {\n            logger.error(\"Failed to save reaction role: \" + e.getMessage());\n        }\n    }\n    \n    public static Map<Long, Map<String, Long>> loadAllReactionRoles() {\n        Map<Long, Map<String, Long>> reactionRoles = new ConcurrentHashMap<>();\n        \n        if (connection == null) {\n            logger.warn(\"Database not connected - cannot load reaction roles\");\n            return reactionRoles;\n        }\n        \n        String selectSQL = \"SELECT message_id, emoji, role_id FROM reaction_roles\";\n        \n        try (Statement stmt = connection.createStatement();\n             ResultSet rs = stmt.executeQuery(selectSQL)) {\n            \n            while (rs.next()) {\n                long messageId = rs.getLong(\"message_id\");\n                String emoji = rs.getString(\"emoji\");\n                long roleId = rs.getLong(\"role_id\");\n                \n                reactionRoles.putIfAbsent(messageId, new ConcurrentHashMap<>());\n                reactionRoles.get(messageId).put(emoji, roleId);\n            }\n            \n            logger.info(\"Loaded \" + reactionRoles.size() + \" reaction role messages from database\");\n        } catch (SQLException e) {\n            logger.error(\"Failed to load reaction roles: \" + e.getMessage());\n        }\n        \n        return reactionRoles;\n    }\n    \n    public static void deleteReactionRoleMessage(long messageId) {\n        if (connection == null) return;\n        \n        String deleteSQL = \"DELETE FROM reaction_roles WHERE message_id = ?\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(deleteSQL)) {\n            pstmt.setLong(1, messageId);\n            int deleted = pstmt.executeUpdate();\n            logger.info(\"Deleted \" + deleted + \" reaction role entries for message \" + messageId);\n        } catch (SQLException e) {\n            logger.error(\"Failed to delete reaction roles for message: \" + e.getMessage());\n        }\n    }\n    \n    public static void saveBotStatusMessageId(long messageId) {\n        if (connection == null) return;\n        \n        try {\n            if (connection.isClosed()) {\n                logger.warn(\"Database connection is closed, reinitializing...\");\n                initialize();\n                if (connection == null) return;\n            }\n        } catch (SQLException e) {\n            logger.error(\"Error checking connection status: \" + e.getMessage());\n            return;\n        }\n        \n        String upsertSQL = \"INSERT INTO bot_config (config_key, config_value) VALUES ('status_message_id', ?) ON CONFLICT (config_key) DO UPDATE SET config_value = ?\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(upsertSQL)) {\n            pstmt.setString(1, String.valueOf(messageId));\n            pstmt.setString(2, String.valueOf(messageId));\n            pstmt.executeUpdate();\n            logger.debug(\"Saved bot status message ID: \" + messageId);\n        } catch (SQLException e) {\n            logger.error(\"Failed to save bot status message ID: \" + e.getMessage());\n        }\n    }\n    \n    public static Long getBotStatusMessageId() {\n        if (connection == null) return null;\n        \n        try {\n            if (connection.isClosed()) {\n                logger.warn(\"Database connection is closed, reinitializing...\");\n                initialize();\n                if (connection == null) return null;\n            }\n        } catch (SQLException e) {\n            logger.error(\"Error checking connection status: \" + e.getMessage());\n            return null;\n        }\n        \n        String selectSQL = \"SELECT config_value FROM bot_config WHERE config_key = 'status_message_id'\";\n        \n        try (Statement stmt = connection.createStatement();\n             ResultSet rs = stmt.executeQuery(selectSQL)) {\n            \n            if (rs.next()) {\n                String value = rs.getString(\"config_value\");\n                return Long.parseLong(value);\n            }\n        } catch (SQLException e) {\n            logger.error(\"Failed to get bot status message ID: \" + e.getMessage());\n        } catch (NumberFormatException e) {\n            logger.error(\"Invalid status message ID in database: \" + e.getMessage());\n        }\n        \n        return null;\n    }\n    \n    public static void logCommand(long serverId, String commandName, long userId, String username, String parameters) {\n        if (connection == null) return;\n        \n        try {\n            if (connection.isClosed()) {\n                logger.warn(\"Database connection is closed, reinitializing...\");\n                initialize();\n                if (connection == null) return;\n            }\n        } catch (SQLException e) {\n            logger.error(\"Error checking connection status: \" + e.getMessage());\n            return;\n        }\n        \n        String insertSQL = \"INSERT INTO command_logs (server_id, command_name, user_id, username, parameters) VALUES (?, ?, ?, ?, ?)\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(insertSQL)) {\n            pstmt.setLong(1, serverId);\n            pstmt.setString(2, commandName);\n            pstmt.setLong(3, userId);\n            pstmt.setString(4, username);\n            pstmt.setString(5, parameters);\n            pstmt.executeUpdate();\n            logger.debug(\"Logged command: \" + commandName + \" by \" + username);\n        } catch (SQLException e) {\n            logger.error(\"Failed to log command: \" + e.getMessage());\n        }\n    }\n    \n    public static void close() {\n        if (connection != null) {\n            try {\n                connection.close();\n                logger.info(\"Database connection closed\");\n            } catch (SQLException e) {\n                logger.error(\"Error closing database connection: \" + e.getMessage());\n            }\n        }\n    }\n}\n","size_bytes":11009},"src/main/java/com/github/koxsosen/listeners/ButtonInteractionListener.java":{"content":"package com.github.koxsosen.listeners;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.javacord.api.entity.channel.ServerTextChannel;\nimport org.javacord.api.entity.channel.ChannelCategory;\nimport org.javacord.api.entity.message.Message;\nimport org.javacord.api.entity.message.embed.EmbedBuilder;\nimport org.javacord.api.entity.permission.PermissionType;\nimport org.javacord.api.entity.permission.Permissions;\nimport org.javacord.api.entity.permission.PermissionsBuilder;\nimport org.javacord.api.entity.server.Server;\nimport org.javacord.api.entity.user.User;\nimport org.javacord.api.event.interaction.MessageComponentCreateEvent;\nimport org.javacord.api.listener.interaction.MessageComponentCreateListener;\n\nimport java.awt.Color;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class ButtonInteractionListener implements MessageComponentCreateListener {\n\n    private static final Logger logger = LogManager.getLogger(ButtonInteractionListener.class);\n    private static final long SUPPORT_ROLE_ID = 1361892370018210007L;\n    private static final long TRANSCRIPT_CHANNEL_ID = 1401835468361826354L;\n    private static final long TICKET_CATEGORY_ID = 1394811350391193791L;\n    private static final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);\n    \n    public static final java.util.Map<String, java.util.Map<Long, Integer>> pollVotes = new java.util.concurrent.ConcurrentHashMap<>();\n    \n    public static void shutdown() {\n        logger.info(\"Shutting down ButtonInteractionListener scheduler...\");\n        scheduler.shutdown();\n        try {\n            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n        }\n    }\n\n    @Override\n    public void onComponentCreate(MessageComponentCreateEvent event) {\n        String customId = event.getMessageComponentInteraction().getCustomId();\n\n        if (customId.startsWith(\"poll_vote_\")) {\n            long messageId = event.getMessageComponentInteraction().getMessage().getId();\n            long userId = event.getMessageComponentInteraction().getUser().getId();\n            String voteOption = customId.split(\"_\")[2];\n            \n            String messageKey = String.valueOf(messageId);\n            pollVotes.putIfAbsent(messageKey, new java.util.concurrent.ConcurrentHashMap<>());\n            pollVotes.get(messageKey).put(userId, Integer.parseInt(voteOption));\n            \n            event.getMessageComponentInteraction().createImmediateResponder()\n                .setContent(\"‚úÖ Vote recorded!\")\n                .setFlags(org.javacord.api.entity.message.MessageFlag.EPHEMERAL)\n                .respond();\n            return;\n        }\n\n        if (customId.equals(\"session_vote_btn\")) {\n            handleSessionVoteButton(event);\n            return;\n        }\n\n        if (customId.equals(\"open_ticket\")) {\n            handleTicketCreation(event);\n        } else if (customId.equals(\"claim_ticket\")) {\n            handleTicketClaim(event);\n        } else if (customId.equals(\"close_ticket\")) {\n            handleTicketClose(event);\n        }\n    }\n\n    private void handleTicketCreation(MessageComponentCreateEvent event) {\n        event.getMessageComponentInteraction().acknowledge();\n\n        User user = event.getMessageComponentInteraction().getUser();\n        Server server = event.getMessageComponentInteraction().getServer().orElse(null);\n\n        if (server == null) {\n            return;\n        }\n\n        String baseTicketName = user.getName().toLowerCase().replaceAll(\"[^a-z0-9]\", \"\");\n        \n        long ticketCount = server.getTextChannels().stream()\n            .filter(ch -> ch.getName().startsWith(baseTicketName + \"-\"))\n            .count();\n        \n        String ticketChannelName = baseTicketName + \"-\" + (ticketCount + 1);\n\n        java.util.Optional<ServerTextChannel> existingTicket = server.getTextChannels().stream()\n            .filter(ch -> ch.getName().startsWith(baseTicketName + \"-\"))\n            .filter(ch -> {\n                try {\n                    ch.getMessages(1).join();\n                    return true;\n                } catch (Exception e) {\n                    return false;\n                }\n            })\n            .filter(ch -> {\n                Permissions perms = ch.getEffectiveOverwrittenPermissions(user);\n                return perms.getAllowedPermission().contains(PermissionType.VIEW_CHANNEL);\n            })\n            .findFirst();\n        \n        if (existingTicket.isPresent()) {\n            event.getMessageComponentInteraction().createFollowupMessageBuilder()\n                .setContent(\"‚ùå You already have an open ticket: \" + existingTicket.get().getMentionTag())\n                .send();\n            return;\n        }\n\n        if (!existingTicket.isPresent()) {\n            if (!server.getRoleById(SUPPORT_ROLE_ID).isPresent()) {\n                event.getMessageComponentInteraction().createFollowupMessageBuilder()\n                    .setContent(\"‚ùå Support role is not configured. Please contact an administrator.\")\n                    .send();\n                logger.error(\"Support role ID \" + SUPPORT_ROLE_ID + \" not found in server!\");\n                return;\n            }\n\n            Permissions userPermissions = new PermissionsBuilder()\n                .setAllowed(PermissionType.VIEW_CHANNEL, PermissionType.SEND_MESSAGES, PermissionType.READ_MESSAGE_HISTORY)\n                .build();\n\n            Permissions everyonePermissions = new PermissionsBuilder()\n                .setDenied(PermissionType.VIEW_CHANNEL)\n                .build();\n\n            Permissions supportPermissions = new PermissionsBuilder()\n                .setAllowed(PermissionType.VIEW_CHANNEL, PermissionType.SEND_MESSAGES, PermissionType.READ_MESSAGE_HISTORY, PermissionType.MANAGE_MESSAGES)\n                .build();\n\n            var channelBuilder = server.createTextChannelBuilder()\n                .setName(ticketChannelName)\n                .addPermissionOverwrite(user, userPermissions)\n                .addPermissionOverwrite(server.getEveryoneRole(), everyonePermissions)\n                .addPermissionOverwrite(server.getRoleById(SUPPORT_ROLE_ID).get(), supportPermissions);\n            \n            // Set category if it exists\n            server.getChannelCategoryById(TICKET_CATEGORY_ID).ifPresent(category -> {\n                channelBuilder.setCategory(category);\n            });\n            \n            channelBuilder.create()\n                .thenAccept(channel -> {\n                    EmbedBuilder embed = new EmbedBuilder()\n                        .setTitle(\"üé´ Ticket Opened\")\n                        .setDescription(\"Please explain why you opened this ticket.\")\n                        .setColor(Color.decode(\"#005A9C\"))\n                        .setFooter(\"Support Team will assist you shortly\");\n\n                    channel.sendMessage(\n                        user.getMentionTag() + \" <@&\" + SUPPORT_ROLE_ID + \">\",\n                        embed\n                    ).thenAccept(msg -> {\n                        msg.createUpdater()\n                            .addComponents(\n                                org.javacord.api.entity.message.component.ActionRow.of(\n                                    org.javacord.api.entity.message.component.Button.success(\"claim_ticket\", \"Claim Ticket\"),\n                                    org.javacord.api.entity.message.component.Button.danger(\"close_ticket\", \"Close Ticket\")\n                                )\n                            )\n                            .applyChanges();\n                    });\n\n                    event.getMessageComponentInteraction().createFollowupMessageBuilder()\n                        .setContent(\"‚úÖ Ticket created: \" + channel.getMentionTag())\n                        .setFlags(org.javacord.api.entity.message.MessageFlag.EPHEMERAL)\n                        .send();\n\n                    logger.info(\"Ticket created for user: \" + user.getDiscriminatedName() + \" - Channel: \" + ticketChannelName);\n                })\n                .exceptionally(e -> {\n                    event.getMessageComponentInteraction().createFollowupMessageBuilder()\n                        .setContent(\"‚ùå Failed to create ticket. Please contact an administrator.\")\n                        .send();\n                    logger.error(\"Failed to create ticket channel: \" + e.getMessage());\n                    return null;\n                });\n        }\n    }\n\n    private void handleTicketClaim(MessageComponentCreateEvent event) {\n        event.getMessageComponentInteraction().acknowledge();\n\n        User claimer = event.getMessageComponentInteraction().getUser();\n        Server server = event.getMessageComponentInteraction().getServer().orElse(null);\n\n        if (server == null) {\n            return;\n        }\n\n        boolean hasSupportRole = server.getRoleById(SUPPORT_ROLE_ID)\n            .map(role -> claimer.getRoles(server).contains(role))\n            .orElse(false);\n\n        if (!hasSupportRole) {\n            event.getMessageComponentInteraction().createFollowupMessageBuilder()\n                .setContent(\"‚ùå Only support staff can claim tickets!\")\n                .send();\n            return;\n        }\n\n        ServerTextChannel channel = event.getMessageComponentInteraction().getChannel()\n            .flatMap(c -> c.asServerTextChannel()).orElse(null);\n\n        if (channel != null && (channel.getName().matches(\"^[a-z0-9]+-\\\\d+$\") || channel.getName().startsWith(\"ticket-\"))) {\n            event.getMessageComponentInteraction().createFollowupMessageBuilder()\n                .setContent(\"‚úÖ You have claimed this ticket!\")\n                .setFlags(org.javacord.api.entity.message.MessageFlag.EPHEMERAL)\n                .send();\n\n            logger.info(claimer.getDiscriminatedName() + \" claimed ticket: \" + channel.getName());\n        }\n    }\n\n    private void handleTicketClose(MessageComponentCreateEvent event) {\n        logger.info(\"Close ticket button clicked by \" + event.getMessageComponentInteraction().getUser().getDiscriminatedName());\n        event.getMessageComponentInteraction().acknowledge();\n\n        User closer = event.getMessageComponentInteraction().getUser();\n        Server server = event.getMessageComponentInteraction().getServer().orElse(null);\n\n        if (server == null) {\n            logger.error(\"Server is null in handleTicketClose\");\n            return;\n        }\n\n        boolean hasSupportRole = server.getRoleById(SUPPORT_ROLE_ID)\n            .map(role -> closer.getRoles(server).contains(role))\n            .orElse(false);\n\n        if (!hasSupportRole) {\n            logger.warn(closer.getDiscriminatedName() + \" tried to close ticket without support role\");\n            event.getMessageComponentInteraction().createFollowupMessageBuilder()\n                .setContent(\"‚ùå Only support staff can close tickets!\")\n                .send();\n            return;\n        }\n\n        ServerTextChannel channel = event.getMessageComponentInteraction().getChannel()\n            .flatMap(c -> c.asServerTextChannel()).orElse(null);\n\n        if (channel == null) {\n            logger.error(\"Could not get channel from interaction in handleTicketClose\");\n            return;\n        }\n\n        logger.info(\"Processing ticket close for channel: \" + channel.getName());\n\n        if (channel != null && (channel.getName().matches(\"^[a-z0-9]+-\\\\d+$\") || channel.getName().startsWith(\"ticket-\"))) {\n            Long ticketCreatorId = channel.getOverwrittenUserPermissions().entrySet().stream()\n                .filter(entry -> {\n                    Permissions perms = entry.getValue();\n                    return perms.getAllowedPermission().contains(PermissionType.VIEW_CHANNEL);\n                })\n                .map(entry -> entry.getKey())\n                .findFirst()\n                .orElse(null);\n            \n            User ticketCreator = ticketCreatorId != null ? server.getMemberById(ticketCreatorId).orElse(null) : null;\n            \n            event.getMessageComponentInteraction().createFollowupMessageBuilder()\n                .setContent(\"üîí Saving transcript and closing ticket...\")\n                .send();\n\n            logger.info(\"Starting to fetch all messages from ticket channel: \" + channel.getName());\n            \n            getAllMessages(channel, new java.util.ArrayList<>())\n            .exceptionally(ex -> {\n                logger.error(\"Failed to fetch messages for transcript: \" + ex.getMessage(), ex);\n                event.getMessageComponentInteraction().createFollowupMessageBuilder()\n                    .setContent(\"‚ö†Ô∏è Failed to generate transcript, but closing ticket anyway...\")\n                    .send();\n                // Still proceed to delete the channel even if transcript fails\n                scheduler.schedule(() -> {\n                    channel.delete().thenRun(() -> {\n                        logger.info(\"Ticket closed and deleted (without transcript): \" + channel.getName());\n                    }).exceptionally(e -> {\n                        logger.error(\"Failed to delete ticket channel: \" + e.getMessage());\n                        return null;\n                    });\n                }, 3, TimeUnit.SECONDS);\n                return new java.util.ArrayList<>();\n            })\n            .thenAccept(allMessages -> {\n                logger.info(\"Fetched \" + allMessages.size() + \" messages for transcript\");\n                \n                // Build transcript text\n                StringBuilder transcript = new StringBuilder();\n                \n                allMessages.stream()\n                    .sorted((m1, m2) -> m1.getCreationTimestamp().compareTo(m2.getCreationTimestamp()))\n                    .forEach(msg -> {\n                        java.time.LocalDateTime timestamp = java.time.LocalDateTime.ofInstant(\n                            msg.getCreationTimestamp(), \n                            java.time.ZoneId.systemDefault()\n                        );\n                        String formattedTime = timestamp.format(DateTimeFormatter.ofPattern(\"HH:mm\"));\n                        String author = msg.getAuthor().getName();\n                        String content = msg.getContent();\n                        \n                        // Remove pings/mentions from content\n                        String sanitizedContent = content.replaceAll(\"<@[!&]?\\\\d+>\", \"@user\");\n                        \n                        transcript.append(\"**[\").append(formattedTime).append(\"] \")\n                            .append(author).append(\":**\\n\")\n                            .append(sanitizedContent.isEmpty() ? \"*[Attachment/Embed]*\" : sanitizedContent)\n                            .append(\"\\n\\n\");\n                    });\n\n                logger.info(\"Built transcript text, length: \" + transcript.length());\n\n                java.util.Optional<ServerTextChannel> transcriptChannelOpt = server.getTextChannelById(TRANSCRIPT_CHANNEL_ID);\n                \n                if (!transcriptChannelOpt.isPresent()) {\n                    logger.error(\"Transcript channel not found! ID: \" + TRANSCRIPT_CHANNEL_ID);\n                    event.getMessageComponentInteraction().createFollowupMessageBuilder()\n                        .setContent(\"‚ö†Ô∏è Transcript channel not configured! Closing ticket anyway...\")\n                        .send();\n                    // Still delete the channel\n                    scheduler.schedule(() -> {\n                        channel.delete().thenRun(() -> {\n                            logger.info(\"Ticket closed and deleted (no transcript channel): \" + channel.getName());\n                        }).exceptionally(e -> {\n                            logger.error(\"Failed to delete ticket channel: \" + e.getMessage());\n                            return null;\n                        });\n                    }, 3, TimeUnit.SECONDS);\n                    return;\n                }\n                \n                ServerTextChannel transcriptChannel = transcriptChannelOpt.get();\n                logger.info(\"Found transcript channel: \" + transcriptChannel.getName());\n                    \n                    // Create header embed (no pings)\n                    EmbedBuilder headerEmbed = new EmbedBuilder()\n                        .setTitle(\"üé´ Ticket Transcript: \" + channel.getName())\n                        .setColor(Color.RED)\n                        .addField(\"Closed by\", closer.getName(), true)\n                        .addField(\"Closed at\", \"<t:\" + java.time.Instant.now().getEpochSecond() + \":F>\", true)\n                        .addField(\"Total Messages\", String.valueOf(allMessages.size()), true)\n                        .setTimestamp(java.time.Instant.now());\n                    \n                    // Send header embed first\n                    logger.info(\"Sending header embed to transcript channel...\");\n                    transcriptChannel.sendMessage(headerEmbed).thenAccept(headerMsg -> {\n                        logger.info(\"Header embed sent successfully\");\n                        String transcriptText = transcript.toString();\n                        \n                        // Split transcript into embeds (4096 char limit per description)\n                        java.util.List<java.util.concurrent.CompletableFuture<Message>> futures = new java.util.ArrayList<>();\n                        int chunkSize = 4000; // Leave some room for formatting\n                        \n                        int numChunks = (transcriptText.length() + chunkSize - 1) / chunkSize;\n                        logger.info(\"Splitting transcript into \" + numChunks + \" chunks\");\n                        \n                        for (int i = 0; i < transcriptText.length(); i += chunkSize) {\n                            String chunk = transcriptText.substring(i, Math.min(transcriptText.length(), i + chunkSize));\n                            \n                            EmbedBuilder transcriptEmbed = new EmbedBuilder()\n                                .setDescription(chunk)\n                                .setColor(Color.GRAY);\n                            \n                            futures.add(transcriptChannel.sendMessage(transcriptEmbed));\n                        }\n                        \n                        java.util.concurrent.CompletableFuture<Void> transcriptFuture = \n                            java.util.concurrent.CompletableFuture.allOf(futures.toArray(new java.util.concurrent.CompletableFuture[0]));\n                        \n                        // Wait for all transcript messages to send, then delete channel\n                        transcriptFuture.thenRun(() -> {\n                            logger.info(\"All transcript messages sent successfully for ticket: \" + channel.getName());\n                            \n                            // Send DM to ticket creator if found\n                            if (ticketCreator != null) {\n                                logger.info(\"Sending DM to ticket creator: \" + ticketCreator.getDiscriminatedName());\n                                EmbedBuilder closeEmbed = new EmbedBuilder()\n                                    .setTitle(\"üîí Ticket Closed\")\n                                    .setDescription(\"Your ticket **\" + channel.getName() + \"** has been closed.\")\n                                    .addField(\"Closed by\", closer.getName(), false)\n                                    .setColor(Color.RED)\n                                    .setFooter(\"Thank you for contacting support!\")\n                                    .setTimestamp(java.time.Instant.now());\n                                \n                                ticketCreator.sendMessage(closeEmbed).exceptionally(e -> {\n                                    logger.warn(\"Could not DM ticket creator: \" + e.getMessage());\n                                    return null;\n                                });\n                            }\n                            \n                            // Delete channel after 5 seconds\n                            logger.info(\"Scheduling channel deletion in 5 seconds for: \" + channel.getName());\n                            scheduler.schedule(() -> {\n                                logger.info(\"Deleting ticket channel now: \" + channel.getName());\n                                channel.delete().thenRun(() -> {\n                                    logger.info(\"Ticket closed and deleted successfully: \" + channel.getName());\n                                }).exceptionally(e -> {\n                                    logger.error(\"Failed to delete ticket channel: \" + e.getMessage(), e);\n                                    return null;\n                                });\n                            }, 5, TimeUnit.SECONDS);\n                        }).exceptionally(e -> {\n                            logger.error(\"Failed to send transcript messages: \" + e.getMessage(), e);\n                            // Still try to delete the channel even if transcript fails\n                            scheduler.schedule(() -> {\n                                channel.delete().thenRun(() -> {\n                                    logger.info(\"Ticket deleted (transcript send failed): \" + channel.getName());\n                                }).exceptionally(delEx -> {\n                                    logger.error(\"Failed to delete ticket channel: \" + delEx.getMessage());\n                                    return null;\n                                });\n                            }, 3, TimeUnit.SECONDS);\n                            return null;\n                        });\n                    }).exceptionally(e -> {\n                        logger.error(\"Failed to send header embed: \" + e.getMessage(), e);\n                        // Still try to delete the channel\n                        scheduler.schedule(() -> {\n                            channel.delete().thenRun(() -> {\n                                logger.info(\"Ticket deleted (header send failed): \" + channel.getName());\n                            }).exceptionally(delEx -> {\n                                logger.error(\"Failed to delete ticket channel: \" + delEx.getMessage());\n                                return null;\n                            });\n                        }, 3, TimeUnit.SECONDS);\n                        return null;\n                    });\n            });\n        }\n    }\n\n    private java.util.concurrent.CompletableFuture<java.util.List<Message>> getAllMessages(ServerTextChannel channel, java.util.List<Message> messages) {\n        java.util.concurrent.CompletableFuture<java.util.List<Message>> future = new java.util.concurrent.CompletableFuture<>();\n        \n        fetchMessagesRecursive(channel, new java.util.ArrayList<>(), null, future);\n        \n        return future;\n    }\n    \n    private void fetchMessagesRecursive(ServerTextChannel channel, java.util.List<Message> accumulated, Message lastMessage, java.util.concurrent.CompletableFuture<java.util.List<Message>> future) {\n        java.util.concurrent.CompletableFuture<org.javacord.api.entity.message.MessageSet> fetchOp;\n        \n        if (lastMessage == null) {\n            fetchOp = channel.getMessages(100);\n        } else {\n            fetchOp = channel.getMessagesBefore(100, lastMessage.getId());\n        }\n        \n        fetchOp.thenAccept(batch -> {\n            if (batch.isEmpty()) {\n                future.complete(accumulated);\n                return;\n            }\n            \n            accumulated.addAll(batch);\n            \n            if (batch.size() < 100) {\n                future.complete(accumulated);\n            } else {\n                Message oldest = batch.stream()\n                    .min((m1, m2) -> Long.compare(m1.getId(), m2.getId()))\n                    .orElse(null);\n                fetchMessagesRecursive(channel, accumulated, oldest, future);\n            }\n        }).exceptionally(ex -> {\n            future.completeExceptionally(ex);\n            return null;\n        });\n    }\n\n    private void handleSessionVoteButton(MessageComponentCreateEvent event) {\n        event.getMessageComponentInteraction().acknowledge();\n        \n        User user = event.getMessageComponentInteraction().getUser();\n        Server server = event.getMessageComponentInteraction().getServer().orElse(null);\n        \n        if (server == null) {\n            return;\n        }\n        \n        if (SlashCommandListener.sessionVotes.contains(user.getId())) {\n            event.getMessageComponentInteraction().createFollowupMessageBuilder()\n                .setContent(\"‚ö†Ô∏è You have already voted!\")\n                .setFlags(org.javacord.api.entity.message.MessageFlag.EPHEMERAL)\n                .send();\n            return;\n        }\n        \n        SlashCommandListener.sessionVotes.add(user.getId());\n        \n        ServerTextChannel channel = event.getMessageComponentInteraction().getChannel()\n            .flatMap(c -> c.asServerTextChannel()).orElse(null);\n        \n        if (channel == null) {\n            return;\n        }\n        \n        int currentVotes = SlashCommandListener.sessionVotes.size();\n        int threshold = SlashCommandListener.sessionVoteThreshold;\n        \n        // Build list of voters\n        StringBuilder votersList = new StringBuilder();\n        for (Long voterId : SlashCommandListener.sessionVotes) {\n            if (votersList.length() > 0) votersList.append(\", \");\n            votersList.append(\"<@\").append(voterId).append(\">\");\n        }\n        \n        // Get the existing message to preserve the image URL\n        Message voteMessage = event.getMessageComponentInteraction().getMessage();\n        \n        EmbedBuilder voteEmbed = new EmbedBuilder()\n            .setTitle(\"üìä Los Angeles Session Vote\")\n            .setDescription(\"Come and vote so we can have an amazing roleplay session together! Click the button below to cast your vote and let's get this session started! üéâ\\n\\n**Votes:** \" + currentVotes + \"/\" + threshold + \"\\n**Voters:** \" + votersList.toString() + \"\\n**Join Code:** `LARPVCOS`\")\n            .setColor(Color.decode(\"#00BFFF\"))\n            .setTimestamp(java.time.Instant.now());\n        \n        // Preserve the image from the original message\n        if (!voteMessage.getEmbeds().isEmpty() && voteMessage.getEmbeds().get(0).getImage().isPresent()) {\n            voteEmbed.setImage(voteMessage.getEmbeds().get(0).getImage().get().getUrl().toString());\n        }\n        \n        // Edit the existing vote message instead of deleting and resending\n        voteMessage.createUpdater()\n            .removeAllEmbeds()\n            .addEmbed(voteEmbed)\n            .removeAllComponents()\n            .addComponents(org.javacord.api.entity.message.component.ActionRow.of(\n                org.javacord.api.entity.message.component.Button.primary(\"session_vote_btn\", \"Vote (\" + currentVotes + \"/\" + threshold + \")\")\n            ))\n            .applyChanges().thenAccept(msg -> {\n                if (currentVotes >= threshold) {\n                    // Build voter mentions for punishment warning\n                    StringBuilder voterMentions = new StringBuilder();\n                    for (Long voterId : SlashCommandListener.sessionVotes) {\n                        voterMentions.append(\"<@\").append(voterId).append(\"> \");\n                    }\n                    \n                    SlashCommandListener.sessionVotes.clear();\n                    scheduler.schedule(() -> {\n                        channel.getMessages(100).thenAccept(msgs -> msgs.forEach(m -> m.delete()));\n                        \n                        java.io.File startLogoFile = new java.io.File(\"attached_assets/image_1760418581183.png\");\n                        \n                        EmbedBuilder startEmbed = new EmbedBuilder()\n                            .setTitle(\"üü¢ Los Angeles Session Started\")\n                            .setDescription(\"The session has been started! \" + threshold + \" votes reached!\\n\\nGet ready for an incredible roleplay experience! Join now and let's create some unforgettable moments together! üöìüèôÔ∏è\\n\\n**Join Code:** `LARPVCOS`\")\n                            .setColor(Color.decode(\"#00FF00\"))\n                            .setTimestamp(java.time.Instant.now());\n                        \n                        if (startLogoFile.exists()) {\n                            startEmbed.setImage(startLogoFile);\n                        }\n                        \n                        new org.javacord.api.entity.message.MessageBuilder()\n                            .setContent(\"@everyone\")\n                            .setEmbed(startEmbed)\n                            .send(channel).thenAccept(startMsg -> {\n                                // Send punishment warning to voters\n                                channel.sendMessage(voterMentions.toString() + \"\\n‚ö†Ô∏è **ATTENTION VOTERS:** The session has started! If you don't join, punishments will happen. Join now using code `LARPVCOS`!\");\n                            });\n                    }, 2, TimeUnit.SECONDS);\n                }\n            });\n        \n        event.getMessageComponentInteraction().createFollowupMessageBuilder()\n            .setContent(\"‚úÖ Vote recorded!\")\n            .setFlags(org.javacord.api.entity.message.MessageFlag.EPHEMERAL)\n            .send();\n    }\n}\n","size_bytes":29694},"server.js":{"content":"const express = require('express');\nconst path = require('path');\n\nconst app = express();\nconst PORT = 5000;\n\napp.use(express.json());\napp.use(express.static('public'));\n\n// Configure your webhooks here (generate using the setup page)\nconst WEBHOOKS = {\n    _warm_greetings: 'https://discord.com/api/webhooks/1434349384090386533/TxyQJYtmYj4VDz5UEQBFkYjhsgjiOL21CncLpFkfOETkB1v8bTHjyG5JFYcePE1Fg2cm',\n    _server_rules: 'https://discord.com/api/webhooks/1434349385394684044/aUb7mI-E1i7aIooCagKsAUUUsU88mEgp3sUk1lRRrQbdx1K15ZSpnVB-szNg4J1Uq1z9',\n    _staff_announcements: 'https://discord.com/api/webhooks/1434349387059957953/pwgam56xoJrU3G6vPRBInZrVWxHRnr7B4XaMAUCYLtyZ901Ll9J1UmTXwmDBPJeqaMnL',\n    _server_alerts: 'https://discord.com/api/webhooks/1434349388527833088/_JbQV9U6wyd-ibvZYvDYvDYvsnPdiA1QPpU2cHp-fIl1CGcf2gcigr5QfnivWgJBfThblhM',\n    _bot_commands: 'https://discord.com/api/webhooks/1434349389458968719/_VHE4F-YDlFfOG4fEnxwkTUarrBLB_OE7NMd49SNtCg410DAPcZzrJhYmiugceAVYzpM',\n    _staff_chat: 'https://discord.com/api/webhooks/1434349391556382902/JOF-589uDnKvcfK2ymzCbPDnqBAczfQQMyW5bijzrtasDCVZVjPNmS4g0jxn7pOE6TDN',\n    _ia_review: 'https://discord.com/api/webhooks/1434349392810348564/F8CJi_5SZFTGk8F918HcQL9XAfJc48RFKvztvnyTr0zD8PEiIrYIdM8KGbwqzni9hdIk',\n    _black_listed: 'https://discord.com/api/webhooks/1434349394089476297/LBcD_t8sHfDrDXhx0yQlR1zs-El11AeRD3QXh_8l-mPIhk6CYsUeCjIlRJMbgTLaAqVa',\n    _report_summary: 'https://discord.com/api/webhooks/1434349395490373763/v-jFTWNrzlK_qDBQ24QCFq7R2DsvJnGSziRf59TTdE7IOv_OJr_qej8V4tDT9LkZPLUw',\n    _server_log: 'https://discord.com/api/webhooks/1434349397260374088/JGfvgAiKj2SzIXtq3NvsWf_7U_Ch56JGtfOsQoy488D5L2FEMbl9Fk4viPqKde_lXyZW',\n    _rp_session_rules: 'https://discord.com/api/webhooks/1434349399537877132/Oyko96pibKqbiDcLjadWb0fvdKYDAEuPABH-TxSrPhTD8hjqthrIyt4cIDdLc4o-7iF7',\n    _town_info: 'https://discord.com/api/webhooks/1434349401970708540/BUO_yi3Y6hv8r3-aiGqt1byhjr0f7QYl1yi5nJ0W__pXcCLpCikqthRG3JK0CG2eN1F6',\n    _new_folk: 'https://discord.com/api/webhooks/1434349403522465912/VP_qaDsn4RBhGzGLwojfJr_Jw6drNXlMdCk1maVs7ViT43XUboVFW-w9zd7xpnpLbgpD',\n    _registration: 'https://discord.com/api/webhooks/1434349405250654360/ANDhBuCSJvu9u4LtbekkAqHqd1qBAYq3xrXSU-aQXFw3HG8Qrt49l3aWcevsJwklFy2q',\n    _shift_log: 'https://discord.com/api/webhooks/1434349407326830642/Me9JjFtTlH50_sx5w1aGsBEU9Whud3k2tXm8Dep_EvokH_NYKsyIIg75okQj82LTOCFA',\n    _general_1: 'https://discord.com/api/webhooks/1434349408706625639/3PCX441w7LPNjfwRj-kNF7-hAwL52vgZoZkgm9EKJsrn8yZWsJBraNK4WI1LfqqhaL0X',\n    _general_2: 'https://discord.com/api/webhooks/1434349410644660344/_-jQ89vn3UNmvJ3IljQPj1i7pAqVTFAOll1HNGzRAsK-jPHYf2tRqNHI7yhlGy8oIFdh',\n    _official_media: 'https://discord.com/api/webhooks/1434349412330766407/7rgpBY3k8fnic_B9tCFga3wJve40EBetBoGQtDmpJqoEWs48JNwr9Ls_Sz8kWgnwOdRW',\n    _server_suggestions: 'https://discord.com/api/webhooks/1434349414331191336/3fzzeK8rHSHcguUdQBI5il9laKN6tOz4QilbYT2gyjDpN6wGOlc_nM_KH-cqNfZpM1Sm',\n    _support: 'https://discord.com/api/webhooks/1434349416378138724/V8ZAFMIUnT4cvBQkxw2bjjl-cAVup1kx3V4CJr1-os3vsgqACuZq3F3EOJfO_jSBmYOn',\n    _your_server: 'https://discord.com/api/webhooks/1434349418789732422/gCcNwN2s9p2T55dSY3fcbyo_twebLPRUEOYBLnEn4LW19vMQXhGM-DTi97CegIsA1xl0',\n    _socials: 'https://discord.com/api/webhooks/1434349420320919725/EE363p1IxmeBznBTF2DtZ-rkXRxczAylx1v_hv247m01n_-xv_CEvaL9Jw6KO5TdpmIx'\n};\n\n// Configure your server branding here\nlet serverName = '| Wiskapoka County | Professional RP |';\nlet serverLogo = 'https://cdn.discordapp.com/icons/1370855839304388680/289e4714dd2cd62df81f8ea8749a69d3.png';\n\nconst COLOR_MAP = {\n    red: 0xED4245,\n    green: 0x57F287,\n    blue: 0x5865F2,\n    yellow: 0xFEE75C,\n    purple: 0xEB459E,\n    orange: 0xF26522\n};\n\nasync function sendWebhookMessage(webhookUrl, message, color, serverName, serverIcon, imageUrl) {\n    let embedColor;\n    \n    if (color && color.startsWith('#')) {\n        embedColor = parseInt(color.substring(1), 16);\n    } else {\n        embedColor = COLOR_MAP[color] || COLOR_MAP.blue;\n    }\n    \n    const embed = {\n        description: message,\n        color: embedColor\n    };\n    \n    if (imageUrl) {\n        embed.image = {\n            url: imageUrl\n        };\n    }\n    \n    const payload = {\n        username: serverName || 'Message Sender',\n        avatar_url: serverIcon,\n        embeds: [embed]\n    };\n    \n    const response = await fetch(webhookUrl, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payload)\n    });\n    \n    if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.message || 'Failed to send webhook message');\n    }\n}\n\napp.post('/send-message', async (req, res) => {\n    try {\n        const { channel, message, imageUrl, color, serverName: customName, serverLogo: customLogo } = req.body;\n        \n        if (!channel || !message) {\n            return res.status(400).json({ error: 'Missing required fields' });\n        }\n        \n        const webhookUrl = WEBHOOKS[channel];\n        if (!webhookUrl) {\n            return res.status(400).json({ error: 'Invalid channel selected' });\n        }\n        \n        console.log('Sending message via webhook...');\n        await sendWebhookMessage(\n            webhookUrl,\n            message,\n            color,\n            customName || serverName,\n            customLogo || serverLogo,\n            imageUrl\n        );\n        \n        res.json({ \n            success: true, \n            message: 'Message sent successfully'\n        });\n        \n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ error: error.message });\n    }\n});\n\napp.get('/client-id', (req, res) => {\n    res.json({ clientId: process.env.DISCORD_CLIENT_ID || '' });\n});\n\napp.get('/channels', (req, res) => {\n    const channels = Object.keys(WEBHOOKS).map(key => ({\n        value: key,\n        label: key.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase())\n    }));\n    res.json({ channels, serverName, serverLogo });\n});\n\napp.post('/setup-webhooks', async (req, res) => {\n    try {\n        const { serverId } = req.body;\n        const DISCORD_BOT_TOKEN = process.env.DISCORD_TOKEN;\n        const fs = require('fs');\n        \n        if (!DISCORD_BOT_TOKEN) {\n            return res.status(500).json({ error: 'Discord bot token not configured' });\n        }\n        \n        if (!serverId) {\n            return res.status(400).json({ error: 'Server ID is required' });\n        }\n\n        console.log('Fetching server info for:', serverId);\n        \n        // Fetch server/guild information\n        const guildResponse = await fetch(`https://discord.com/api/v10/guilds/${serverId}`, {\n            headers: {\n                'Authorization': `Bot ${DISCORD_BOT_TOKEN}`\n            }\n        });\n\n        if (!guildResponse.ok) {\n            throw new Error('Failed to fetch server info. Make sure the bot is in the server.');\n        }\n\n        const guild = await guildResponse.json();\n        const fetchedServerName = guild.name;\n        const fetchedServerLogo = guild.icon \n            ? `https://cdn.discordapp.com/icons/${guild.id}/${guild.icon}.png`\n            : 'https://cdn.discordapp.com/embed/avatars/0.png';\n\n        console.log('Fetching channels for server:', serverId);\n        const channelsResponse = await fetch(`https://discord.com/api/v10/guilds/${serverId}/channels`, {\n            headers: {\n                'Authorization': `Bot ${DISCORD_BOT_TOKEN}`\n            }\n        });\n\n        if (!channelsResponse.ok) {\n            throw new Error('Failed to fetch channels. Make sure the bot is in the server.');\n        }\n\n        const channels = await channelsResponse.json();\n        const textChannels = channels.filter(ch => ch.type === 0);\n\n        const webhooks = {};\n        let count = 0;\n\n        for (const channel of textChannels) {\n            try {\n                console.log(`Creating webhook for #${channel.name}`);\n                const webhookResponse = await fetch(`https://discord.com/api/v10/channels/${channel.id}/webhooks`, {\n                    method: 'POST',\n                    headers: {\n                        'Authorization': `Bot ${DISCORD_BOT_TOKEN}`,\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        name: fetchedServerName\n                    })\n                });\n\n                if (webhookResponse.ok) {\n                    const webhook = await webhookResponse.json();\n                    const channelKey = channel.name.toLowerCase().replace(/[^a-z0-9]+/g, '_');\n                    webhooks[channelKey] = `https://discord.com/api/webhooks/${webhook.id}/${webhook.token}`;\n                    count++;\n                }\n            } catch (err) {\n                console.error(`Failed to create webhook for ${channel.name}:`, err);\n            }\n        }\n\n        // Update server.js file automatically\n        try {\n            const serverJsPath = path.join(__dirname, 'server.js');\n            let fileContent = fs.readFileSync(serverJsPath, 'utf8');\n            \n            // Build the new WEBHOOKS object\n            const webhooksCode = `const WEBHOOKS = {\\n${Object.entries(webhooks).map(([key, url]) => `    ${key}: '${url}'`).join(',\\n')}\\n};`;\n            \n            // Build the server info\n            const serverInfoCode = `let serverName = '${fetchedServerName}';\\nlet serverLogo = '${fetchedServerLogo}';`;\n            \n            // Replace WEBHOOKS section\n            fileContent = fileContent.replace(\n                /\\/\\/ Configure your webhooks here.*?\\nconst WEBHOOKS = \\{[^}]*\\};/s,\n                `// Configure your webhooks here (generate using the setup page)\\n${webhooksCode}`\n            );\n            \n            // Replace server info section\n            fileContent = fileContent.replace(\n                /\\/\\/ Configure your server branding here\\nlet serverName = .*?;\\nlet serverLogo = .*?;/s,\n                `// Configure your server branding here\\n${serverInfoCode}`\n            );\n            \n            fs.writeFileSync(serverJsPath, fileContent, 'utf8');\n            console.log('Successfully updated server.js file');\n        } catch (fileError) {\n            console.error('Error updating server.js:', fileError);\n        }\n\n        const code = `const WEBHOOKS = {\\n${Object.entries(webhooks).map(([key, url]) => `    ${key}: '${url}'`).join(',\\n')}\\n};`;\n\n        res.json({\n            success: true,\n            count,\n            code,\n            channels: Object.keys(webhooks),\n            serverName: fetchedServerName,\n            serverLogo: fetchedServerLogo,\n            autoUpdated: true\n        });\n\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ error: error.message });\n    }\n});\n\napp.listen(PORT, '0.0.0.0', () => {\n    console.log(`Server running on port ${PORT}`);\n    console.log(`Open http://localhost:${PORT} to use the message sender`);\n    console.log(`Setup tool available at: http://localhost:${PORT}/setup.html`);\n});\n","size_bytes":11231}},"version":2}